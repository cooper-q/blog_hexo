---
layout: post
title: MySQL索引详解
date: 2019-09-10
keywords: 
top: 10
categories: 
    - MySQL
    - 索引
tags:
    - MySQL
    - 索引
---
# MySQL索引详解(持续更新)
# 1.为什么要用索引
- 索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。
- 索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
- 索引优化应该是对查询性能优化最有效的手段
- 索引能够轻易将查询性能提高好几个数量级
- 索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查

# 2.索引的原理
## 1.索引原理
- 索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。
- 通过不断地缩小想要获取数据地范围来筛选出最终地结果。
- 同时把随机地事件变成顺序地事件，有了这种索引机制我们可以总是用同一种查找方式来锁定数据。
- 数据库不仅面临等值查询、范围查询（<、>、 between、in）、模糊查询（like）、并集查询（or）等等
- 如果把数据进行等值的分段（如果1000条 1-100、101-200,....）如果查999条，可以直接只要找第十段就可以了，但是分成几段比较好？所以会想到搜索树，平均复杂度为lgN，具有不错的查询性能。
- 复杂模型是基于每次相同的操作成本来考虑的。
- 数据库比较复杂，一方面数据是保存到磁盘上，另一方面为了提高性能，每次又可以把部分数据读入内存来计算，访问磁盘的成本大概是访问内存的十万倍，所以简单的查询树难以满足。

## 2.磁盘ID与预读
- 当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓存区总，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。
- 每一次IO读取的数据我们称之为一页（page）。具体一页有多大数据跟操作系统有关，4k或者8k，都去一页数据的时候，实际才发生一次IO

## 3.索引的数据结构
- 每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常量级。所以使用B+树（MySQL写成BTREE）
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/SQL/mysql%20b%2Btree.png' width='500'/>
- 上图为B+树，浅蓝色的块我们称之为一个磁盘块，包含几个数据项（深蓝色）和指针（黄色）
- 磁盘块1包含数据项17和35，包含指针P1、P2、P3,P1表示小于17的磁盘块，p2表示在17和35之间的磁盘块，P3表示大于35的磁盘快
- 真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。
- 非叶子节点只存储指引搜索方向的数据项，如17、35并不真实的存在与数据表中。

## 1.B+树的查找过程
- 如上图所示如果查找数据项29，
- - 1.那么首先会把磁盘快1加载到内存中，发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针
- - 2.通过磁盘块1和P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO
- - 3.29在26和30之间，锁定磁盘快3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询。
- 三层的B+树可以表示上百万的数据，如果上百万的时候只需要上次IO，性能将大大提高，如果没有索引，每个数据项都要发生一次IO，那么总共百万次的IO。

## 2.B+树的性质
### 1.索引字段要尽量的小
- <span style='color:red'>IO次数取决于B+树的高度h。</span>
- <span style='color:red'>假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则h=log(m+1)N</span>
- <span style='color:red'>当数据量N一定的情况下，m越大，h越小，m=磁盘快的大小/数据项的大</span>
- <span style='color:red'>如果数据项占的空间越小，数据项的数量越多，树的高度越低。</span>
- 所以索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。
- 这也是为什么B+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘快的数据项会大幅度下降，导致树增高，当数据项等于1时将会退化成线性表。

### <span style='color:red'>2.索引的最左匹配特性（即从左往右匹配）</span>
- 当B+树的数据项是复合的数据结构，比如（name，age，sex）的时候，B+树是按照从左到右的顺序来建立搜索树的。
- 比如当（张三、20、F）这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和sex，最后得到检索的数据。
- 当（20，F）这样的没有name的数据来的时候，B+树就不知道下一步该检查哪一个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪查询。当（张三，F）时同理。
- 非常重要的特性，索引的最左匹配特性

## 4.MySQL索引管理
### 1.功能
- 索引的功能就是加速查找
- MySQL中的primary key、unique，联合索引也都是索引，这些索引出了加速查找以外，还有约束功能

### 2.MySQL的索引分类
#### 1.索引分类
- 普通索引index:加速查找
- 唯一索引：
- - 主键索引：primary key：加速查找+约束（不为空且唯一）
- - 唯一索引：unique：加速查找+约束（唯一）
- 联合索引
- - primary key(id,name)：联合主键索引
- - unique(id,name):联合唯一索引
- - index(id,name):联合普通索引
- 全文索引fulltext:用于搜索很长一篇文章的时候，效果最好。
- 空间索引spatial：几乎不用

#### 2.示例
```
为某商场做一个会员卡的系统。

这个系统有一个会员表
有下列字段：
会员编号 INT
会员姓名 VARCHAR(10)
会员身份证号码 VARCHAR(18)
会员电话 VARCHAR(10)
会员住址 VARCHAR(50)
会员备注信息 TEXT

那么这个 会员编号，作为主键，使用 PRIMARY
会员姓名 如果要建索引的话，那么就是普通的 INDEX
会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）

#除此之外还有全文索引，即FULLTEXT
会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。
用于搜索很长一篇文章的时候，效果最好。
用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。

#其他的如空间索引SPATIAL，了解即可，几乎不用

各个索引的应用场景
```
# 3.索引的两大类型
## 1.索引分类

- hash类型的索引：查询单条速度快，范围查询慢。
- btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持他）

## 2.不同的存储引擎支持的索引类型
- InnoDB 支持事务，支持行级别锁定，支持B-tree、Full-text等索引，不支持Hash索引。
- MyISAM不支持事务，支持表级别锁定，支持B-tree、Full-text等索引，不支持Hash索引。
- Memory不支持事务，支持表级别锁定，支持B-tree、Hash等索引，不支持Full-text索引。
- NDB支持事务，支持行级别锁定，支持Hash索引，不支持B-tree、Full-text等索引。
- Archive不支持事务，支持表级别锁定，不支持B-tree、Hash、Full-text等索引。

# 4.创建/删除索引的语法
## 1.创建表时添加索引
```
create table 表明 (
    字段名1 数据类型 [完整约束条件...],
    字段名2 数据类型 [完整约束条件...],
    [UNIQUE|FULLTEXT|SPATIAL] index | key
    [索引名](字段名[(长度)] [ASC | DESC])
)
```
## 2.在已存在的表上创建索引
```
create [UNIQUE | FULLTEXT | SPATIAL] index 索引名 on 表名 (字段名[(长度)] [ASC | DESC])
```
## 3.修改已存在的索引
```
alter table 表名 add [UNIQUE | FULLTEXT | SPATIAL] 索引名 (字段名[(长度)] [ASC|DESC]);
```
## 3.删除索引
```
drop index 索引名 on 表名
```
## 4.善用帮助文档
```
善用帮助文档
help create
help create index
==================
1.创建索引
    -在创建表时就创建（需要注意的几点）
    create table s1(
    id int ,#可以在这加primary key
    #id int index #不可以这样加索引，因为index只是索引，没有约束一说，
    #不能像主键，还有唯一约束一样，在定义字段的时候加索引
    name char(20),
    age int,
    email varchar(30)
    #primary key(id) #也可以在这加
    index(id) #可以这样加
    );
    -在创建表后在创建
    create index name on s1(name); #添加普通索引
    create unique age on s1(age);添加唯一索引
    alter table s1 add primary key(id); #添加住建索引，也就是给id字段增加一个主键约束
    create index name on s1(id,name); #添加普通联合索引
2.删除索引
    drop index id on s1;
    drop index name on s1; #删除普通索引
    drop index age on s1; #删除唯一索引，就和普通索引一样，不用在index前加unique来删，直接就可以删了
    alter table s1 drop primary key; #删除主键(因为它添加的时候是按照alter来增加的，那么我们也用alter来删)
```
# <span style='color:red'>5.创建测试数据</span>
## 1.创建test表
```
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for test
-- ----------------------------
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `sex` varchar(255) DEFAULT NULL,
  KEY `nameA` (`name`) USING BTREE,
  KEY `ageA` (`age`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

SET FOREIGN_KEY_CHECKS = 1;
```
## 2.创建存储过程用于插入测试数据
```
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert1()
BEGIN
	declare i int default 1;
	while(i<3000000)do
        insert into test values(concat('name',i),i,concat('sex',i));
        set i=i+1;
  end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号
```
## 3.查看存储过程
```
show create procedure auto_insert1;
```
## 4.调用存储过程
```
call auto_insert1();
```

# <span style='color:red'>6.正确的使用索引</span>
## 1.覆盖索引
```
select * from s1 where id=123;

// 1.该sql命中了索引，但是未覆盖。
// 2.利用id=123到索引的数据结构中定位该id在硬盘中国呢的位置，或者说在数据表中的位置
// 3.如果select *，除了id字段还需要其他字段，意味着，我们通过索引结构取到id还不够。
// 4.还需要利用id再去找所在行其他字段值，这是需要时间的。
// 5.如果只查询id，则会非常快。
```
## 2.联合索引
```
// 未加联合索引查询
select * from test where name='张三' and age=12; // 0.3s

// 创建联合索引
create index nameAge on test(name,age); // OK

// 加了联合索引查询
select * from test where name='张三' and age=12; // 0.01s
```
## 3.索引合并(Index merge optimization)
- 需要开启Index merge特性


>本文章来源于网络，如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)

# 备注

