---
layout:     post
title:      "常用Linux命令，持续更新"
date:       2017-9-18
top: 10
categories:
    - Linux 
catalog:    true
tags:
    - Linux
---

# 常用Linux命令，持续更新
# 1.查看某个端口的占用情况

    lsof -i :80
    kill -9 进程号 杀死进程

# 2.文件&文件夹
## 1.查询指定位置的文件
    find controller/ -name '*.js' | xargs grep 'decorator'  查询指定目录下 指定

## 2.删除 rm
### 1.递归删除所有
    rm -rf [file|folder]

    -f, --force    忽略不存在的文件，从不给出提示。
    -i, --interactive 进行交互式删除
    -r, -R, --recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。
    -v, --verbose    详细显示进行的步骤
      	--help     显示此帮助信息并退出
      	--version  输出版本信息并退出

### 2.删除指定目录文件夹

    find path(路径) -name 名称|xargs rm -rf

## 3.操作文件&文件夹

    1. file 文件名
        可以查看文件类型;
    2. 或者:  more  文件名
        查看文件内容是否可读文本
    3. 修改权限
        chmod 777 文件名
        或者： chmod a+x 文件名
        如果没有权限， 需要文件属主或管理员用户（root）执行
    4.写入文件
        echo '123' > filename
    5.查看文件或者文件夹大小
        du -h fileName&path
        du -ah // 查看当前文件夹内容
        du -ah fileName // 查看指定文件大小
        du -ah path // 查看这个文件夹下的文件的大小
        
    6.新建文件夹
        mkdir  文件夹名字
    7.新建文件
        touch 文件名称

    8.移动并重新命名
        mv matt.meng  ~/.ssh/id_rsa
        mv matt.meng ~/.ssh/id_rsa.pub
    9.修改文件/文件夹
        mv 修改前名字  修改后的

    10.copy文件夹、文件
        cp -R directory newDirectory
        cp 文件名 路径+新文件名


    11.rmdir用来删除空目录
        rmdir(选项)(参数)

        选项：
            -p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除； --ignore-fail-on-non-empty：此选项使rmdir命令忽略由于删除非空目录时导致的错误信息； -v或-verboes：显示命令的详细执行过程； --help：显示命令的帮助信息； --version：显示命令的版本信息。

        参数：
            目录列表：要删除的空目录列表。当删除多个空目录时，目录名之间使用空格隔开。
        ex：
            rmdir /Desktop/null


    12.显示这个文件夹下的文件 并搜索名称为AuthorizedKeysFile文件

        cat /etc/ssh/sshd_config |grep AuthorizedKeysFile
        cat demo |grep a 搜索这个文件下面的a

    13.tree&&ls
        tree -L 1 显示一级目录
        ls -lh 查看文件大写
        ls -1 把文件或者文件夹排列成一列
        统计个数

        查看当前目录下的文件数量（不包含子目录中的文件）
        ls -l|grep "^-"| wc -l

        查看当前目录下的文件数量（包含子目录中的文件） 注意：R，代表子目录
        ls -lR|grep "^-"| wc -l

        查看当前目录下的文件夹目录个数（不包含子目录中的目录），同上述理，如果需要查看子目录的，加上R
        ls -l|grep "^d"| wc -l

        查询当前路径下的指定前缀名的目录下的所有文件数量
        例如：统计所有以“20161124”开头的目录下的全部文件数量
        ls -lR 20161124*/|grep "^-"| wc -l
        
        -a 列出目录下的所有文件，包括以 . 开头的隐含文件。
        -b 把文件名中不可输出的字符用反斜杠加字符编号(就象在C语言里一样)的形式列出。
        -c 输出文件的 i 节点的修改时间，并以此排序。
        -d 将目录象文件一样显示，而不是显示其下的文件。
        -e 输出时间的全部信息，而不是输出简略信息。
        -f -U 对输出的文件不排序。
        -g 无用。
        -i 输出文件的 i 节点的索引信息。
        -k 以 k 字节的形式表示文件的大小。
        -l 列出文件的详细信息。
        -m 横向输出文件名，并以“，”作分格符。
        -n 用数字的 UID,GID 代替名称。
        -o 显示文件的除组信息外的详细信息。
        -p -F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。
        -q 用?代替不可输出的字符。
        -r 对目录反向排序。
        -s 在每个文件名后输出该文件的大小。
        -t 以时间排序。
        -u 以文件上次被访问的时间排序。
        -x 按列输出，横向排序。
        -A 显示除 “.”和“..”外的所有文件。
        -B 不输出以 “~”结尾的备份文件。
        -C 按列输出，纵向排序。
        -G 输出文件的组的信息。
        -L 列出链接文件名而不是链接到的文件。
        -N 不限制文件长度。
        -Q 把输出的文件名用双引号括起来。
        -R 列出所有子目录下的文件。
        -S 以文件大小排序。
        -X 以文件的扩展名(最后一个 . 后的字符)排序。
        -1 一行只输出一个文件。
        
        ls实现列文件按时间排序
        
        1) ls -lt  时间最近的在前面
        2) ls -ltr 时间从前到后
        
        3) 利用sort
        
          ls -l | sort +7 (日期为第8列)  时间从前到后
        ls -l | sort -r +7 时间最近的在前面


    14.文件&文件夹权限

        1.查看以及用来更改某个目录活文件访问权限

            ### chmod 修改某个文件

            ls -l xxx.xx
            -rw-rw-r--
            其中：
                最前面那个 - 代表的是类型
                中间那三个 rw- 代表的是所有者（user）
                然后那三个 rw- 代表的是群组（group）
                最后那三个 r-- 代表的是其他人(other)

                r--read
                w--write
                x 文件可以被执行
                - 表示相应的权限还没有被赋予

            chmod o+w xxx.xx
            表示给其他人授予这个文件的权限

            chmod go-rw xxx.xx
            表示删除xxx.xx中的群组和其他人的读和写的权限。

                u 所有者
                g group
                o 代表其他人 但不是u和g
                a 代表全部的人 u g o
            数字代替
                -rw------- 600 只有所有者才有读写权限。
                -rw-r--r-- 644 只有所有者才有读写权限，组群和其他人只要读的权限。
                -rwx------ 700 只要所有者才有读写执行的权利
                -rwxr-xr-x 755 只有所有者才有读写执行的权利，组群和其他人只有读和执行的权限
                -rwx--x--x 711 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限
                -rw-rw-rw- 666 每个人都有读写的权限
                -rwxrwxrwx 777 每个人都有读写和执行的权限

        2.修改某个目录或文件的用户名和用户组的权限

            chown 用户名:组名 文件路径（绝对or相对）
            参数：
                -c 显示更改的部分信息
                -f 忽略错误信息
                -h 修复符号链接
                -R 处理指定目录以及其子目录下的所有文件
                -v 显示详细的处理信息
                -deference 作用与符号链接的指向，而不是链接文件本身。
    15.>> >
        >定向数据文件，如果文件不存在就创建文件，如果文件存在清空。
        >>将内容追加到目标文件。

# 3.pscp&scp

## 1.利用pscp上传文件
```
pscp d:\project\udpServer.zip root@101.201.30.9:/home
```
## 2.scp下载文件
```
scp walle@52.80.63.5:/home/apps/sensor-tcp/tmp/fileName.txt 本地地址
sudo echo ""  > hosts 清空hosts
scp -P port // 指定端口

// scp指定端口 指定秘钥下载 
scp -P xxxx -i /Users/xxx/.ssh/id_rsa root@xxx.xx.xx.xx:/etc/xx/config.json ./
```

## 3.scp 上传文件
```
scp  -r /tmp/local_dir username@ip:remote_dir
```
# 4.查看相关命令的帮助文档

    tldr 查看某个命令的help

# 5.打包/解压

>tar命令

    解包：tar zxvf FileName.tar
    打包：tar czvf FileName.tar DirName

>gz命令
    
    解压1：gunzip FileName.gz
    解压2：gzip -d FileName.gz
    压缩：gzip FileName
    .tar.gz 和 .tgz
    解压：tar zxvf FileName.tar.gz
    压缩：tar zcvf FileName.tar.gz DirName

    压缩多个文件：tar zcvf FileName.tar.gz DirName1 DirName2 DirName3 ...

>bz2命令
    
    解压1：bzip2 -d FileName.bz2
    解压2：bunzip2 FileName.bz2
    压缩： bzip2 -z FileName
    .tar.bz2
    解压：tar jxvf FileName.tar.bz2
    压缩：tar jcvf FileName.tar.bz2 DirName
>bz命令
    
    解压1：bzip2 -d FileName.bz
    解压2：bunzip2 FileName.bz
    压缩：未知
    .tar.bz
    解压：tar jxvf FileName.tar.bz
>Z命令
   
    解压：uncompress FileName.Z
    压缩：compress FileName
    .tar.Z
    解压：tar Zxvf FileName.tar.Z
    压缩：tar Zcvf FileName.tar.Z DirName
>zip命令
    
    解压：unzip FileName.zip
    压缩：zip -r FileName.zip DirName
    压缩密码：zip -e 要压缩的压缩包生成的路径（./zip.zip） 文件名称 文件名称（多个文件用空格隔开）
    tar -c创建包 -X释放包 -v显示命令过程 -z代表压缩包
    tar -cvf benet.tar /home/benet 把/home/benet目录打包
    tar -zcvf benet.tar /mnt 把目录打包并压缩
    tar -zxvf benet.tar.gz 压缩包的文件解压恢复
    tar -jxvf benet.tar.gz bz2解压缩
    unzip 解压zip文件

# 6.linux 打开关闭防火墙（待补充）

    service iptables statue

# 7.PATH

    查看PATH值
        export
    问题：
        长时间没弄path会失效 所以会出现找不到的情况
    添加path
        vi /etc/profile
        在文档的最后，添加：
            export PATH="/usr/local/nginx:$PATH"
        保存，退出
            source /etc/profile
    程序自带的shell命令是从env中的PATH找到的
    uri：/usr/bin/env
>格式
```
PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH N>

你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$ source .bash_profile
```

# 8.查看内存CPU使用情况


    top
    top -u process_name
    //退出q
    PID：进程的ID
    USER：进程所有者
    PR：进程的优先级别，越小越优先被执行
    NInice：值
    VIRT：进程占用的虚拟内存
    RES：进程占用的物理内存
    SHR：进程使用的共享内存
    S：进程的状态。
        S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
    %CPU：进程占用CPU的使用率
    %MEM：进程使用的物理内存和总内存的百分比
    TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
    COMMAND：进程启动命令名称

    Linux
        free 查看占用内存
　　
# 9.xargs

    之所以用这个命令，关键是有很多的命令不知道管道传递参数。xargs命令。
    例如：
        find /sbin -perm + 700 |ls-1 //这是不对的
        find /sbin -perm + 700|xargs ls -1//这是对的

# 10.base64

    echo '要转换的内容'|base64 (encoded，编码)

    echo 'aGVsbG8K'|base64 -D  (decoded,解码)

# 11. nc

## 1.端口扫描
        nc -z -v -n 172.31.100.7 21-25
        可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.
        这个命令会打印21到25 所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。
        一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。
        -4 IPv4
        -6 IPv6
        -A 设置SO_RECV_ANYIF 给socket，除非要发送超级大的包的时候会用到。
        -a 设置SO_AWDL_UNRESTRICTED
        -b Bind socket to interface
        -c 发送CRLF作为结束符
        -C 不使用移动网络
        -D 启动debug模式
        -d 后台模式        -------------------------------（只windows下可用）
        -e prog 程序重定向，一旦连接，就执行 [危险!!]  (只windows下可用)
        -F Do not use flow advisory (flow adv enabled by default)
        -G 超时时间
        -h 帮助
        -H keepidle	Initial idle timeout in seconds
        -I keepintvl	Interval for repeating idle timeouts in seconds
        -i<延迟秒数>  设置时间间隔，以便传送信息及扫描通信端口。
        -J 重复超时的次数
        -k	保持多个链接
        -K Specify traffic class
        -l 监听模式，查看是否有错误。
        -L num_probes Number of probes to send before generating a read timeout event
        -m		Set SO_INTCOPROC_ALLOW on socket
        -n  直接使用IP地址，而不通过域名服务器。
        -M		Use MULTIPATH domain socket
        -N num_probes Number of probes to send before generating a write timeout event
        -O		Use old-style connect instead of connectx
        -p port 指定远程端口，但是不可以使用-l
        -r 随机远程端口
        -s addr		Local source address
        -t 使nc能够与telnet交互
        -U		Use UNIX domain socket
        -u 使用UDP传输协议。
        -v 详细输出--用两个-v可得到更详细的内容
        -w <超时秒数>  设置等待连线的时间。
        -X proto	Proxy protocol: "4", "5" (SOCKS) or "connect"
        -x addr[:port]	Specify proxy address and port
        -z  使用输入/输出模式，只在扫描通信端口时使用
        -o		Issue socket options after connect/bind
        --apple-delegate-pid pid	Set socket as delegate using pid

## 2.传输tcp包
        echo 'hello'|nc -n 127.0.0.1 5004
        回车继续发送tcp，请求

# 12.echo

    功能说明：打印文字
>参数说明

    -n 不换行
    -e 打印带颜色
>打印文字带颜色
    
    基本格式
    echo -e "\033[字背景颜色;文字颜色m字符串\033[0m"
    例如：
    echo -e "\033[41;37m Tony Zhang \033[0m" // 其中41 代表底色、37代表字的颜色
    注：
    1、字背景颜色和文字颜色之间是英文的“""”
    2、文字颜色后面有个m
    3、字符串前后可以没有空格，如果有的话，输出也是同样有空格
    
    实例
    echo -e "\033[30m 黑色字 \033[0m"
    echo -e "\033[31m 红色字 \033[0m"
    echo -e "\033[32m 绿色字 \033[0m"
    echo -e "\033[33m 黄色字 \033[0m"
    echo -e "\033[34m 蓝色字 \033[0m"
    echo -e "\033[35m 紫色字 \033[0m"
    echo -e "\033[36m 天蓝字 \033[0m"
    echo -e "\033[37m 白色字 \033[0m"
    echo -e "\033[40;37m 黑底白字 \033[0m"
    echo -e "\033[41;37m 红底白字 \033[0m"
    echo -e "\033[42;37m 绿底白字 \033[0m"
    echo -e "\033[43;37m 黄底白字 \033[0m"
    echo -e "\033[44;37m 蓝底白字 \033[0m"
    echo -e "\033[45;37m 紫底白字 \033[0m"
    echo -e "\033[46;37m 天蓝底白字 \033[0m"
    echo -e "\033[47;30m 白底黑字 \033[0m"
    
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/shell/echo%20font%20color.png' width='100px'/>

>控制选项说明

    \33[0m 关闭所有属性
    \33[1m 设置高亮度
    \33[4m 下划线
    \33[5m 闪烁
    \33[7m 反显
    \33[8m 消隐
    \33[30m -- \33[37m 设置前景色
    \33[40m -- \33[47m 设置背景色
    \33[nA 光标上移n行
    \33[nB 光标下移n行
    \33[nC 光标右移n行
    \33[nD 光标左移n行
    \33[y;xH设置光标位置
    \33[2J 清屏
    \33[K 清除从光标到行尾的内容
    \33[s 保存光标位置
    \33[u 恢复光标位置
    \33[?25l 隐藏光标
    \33[?25h 显示光标

# 13.alias

    alias 快捷名字='要执行的命令'
    alias 快捷名字='要执行的命令'|'其他命令'
    # 传递参数 alias 不支持参数，但是可以提供一个function
    # $1 第一个参数 $2 第二个参数
        alias 快捷键名字='add(){
            git add app/controller app/dao app/router app/service;
            git commit -m $1;
        };add'
    # 取消别名
    unalias 别名名称

    zsh 增加别名
        vim ~/.zshrc
    bash 增加别名
        vim /etc/bashrc
    .bash_profile和.bashrc的区别
    一个在etc下面一个根目录下面
    etc下面的是全系统通用的权限比较大，~/下是当前用户的
        


# 14.curl
[参考资料](http://www.cnblogs.com/duhuo/p/5695256.html)

>1.curl url 下载单个文件

>2.通过-o/-O选项保存下载的文件到指定文件中
        
    # 将文件下载到本地并命名为mygettext.html
    curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html
    # 将文件保存到本地并命名为gettext.html
    curl -O http://www.gnu.org/software/gettext/manual/gettext.html
    同时获取多个文件
    curl -o url -o url
    
>3.断点续传
 
    # 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载
    curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html
    
>4.对curl进行网络限速、时间

>5.curl授权

    curl -u username:password URL
    # 通常的做法是在命令行只输入用户名，之后会提示输入密码，这样可以保证在查看历史记录时不会将密码泄露
    curl -u username url

>    6.从FTP服务器下载文件
    
    # 列出public_html下的所有文件夹和文件
    curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/

    # 下载xss.php文件
    curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php

>7.上传文件到FTP服务器

    通过 -T 选项可将指定的本地文件上传到FTP服务器上
    # 将myfile.txt文件上传到服务器
    curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com

    # 同时上传多个文件
    curl -u ftpuser:ftppass -T "{file1,file2}" ftp://ftp.testserver.com

    # 从标准输入获取内容保存到服务器指定的文件中
    curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt

>8.通过-v、-trace获取更多的链接信息

>9.通过字典查询单词
 
    # 查询bash单词的含义
    curl dict://dict.org/d:bash

    # 列出所有可用词典
    curl dict://dict.org/show:db

    # 在foldoc词典中查询bash单词的含义
    curl dict://dict.org/d:bash:foldoc
    
>10.curl设置代理

    # 指定代理主机和端口
    curl -x proxysever.test.com:3128 http://google.co.in

>11.保存与使用其他网站的cookie信息
 
    # 将网站的cookies信息保存到sugarcookies文件中
    curl -D sugarcookies http://localhost/sugarcrm/index.php
    # 使用上次保存的cookie信息
    curl -b sugarcookies http://localhost/sugarcrm/index.php

>12.传递请求参数POST GET
 
    默认curl使用GET方式请求数据，这种方式下直接通过URL传递数据
    可以通过 --data/-d 方式指定使用POST方式传递数据
    # GET
    curl -u username https://api.github.com/user?access_token=XXXXXXXXXX

    # POST
    curl -u username --data "param1=value1&param2=value" https://api.github.com
    
    curl -d 'ip=222.72.140.114' http://ip.taobao.com/service/getIpInfo2.php
    
    curl -H "Content-Type:application/x-www-form-urlencoded" -X POST -d 'ip=222.72.140.114' http://ip.taobao.com/service/getIpInfo2.php
    
    # 也可以指定一个文件，将该文件中的内容当作数据传递给服务器端
    curl --data @filename https://github.api.com/authorizations

    # 如果特殊字符需要转义
    # 直接使用--data-urlencode会自动转义
    curl --data-urlencode "value 1" http://hostname.com

    # 除了GET、POST，还可以通过-X指定请求方式。
    curl -I -X DELETE https://api.github.com
    # 上传文件
    curl --form "fileupload=@filename.txt" http://hostname/resource

 >忽略https
    
    curl https://127.0.0.1:9802/api/promote/template -k
>不显示统计信息 % Total %Received%

```
curl -s 
```

>curl不识别 ? （zsh: no matches found:）

- 出现这个问题是由于zsh引起的
```
curl 127.0.0.1:4001/get_traffic/query?key=1
// zsh: no matches found: 127.0.0.1:4001/get_traffic/query?key=1

// 1.在 ~/.zshrc 中加入：setopt no_nomatch 
// 2.执行 source ~/.zshrc
```

# 15.查看socket连接数

    ulimit -n
    修改socket连接数
    sudo vim /etc/security/limits.conf
    * soft nofile 65535
    * hard nofile 65535

# 16.执行脚本的四种方法

    1.  ./脚本.sh
    2.使用全路径执行 /Users/mengxiangcun/semioe/private/tool/hello.sh
    3.直接使用bash or sh来执行
        bash hello.sh
        sh hello.sh
    4.在当前环境执行shell脚本。
        . ./hello.sh
        source hello.sh

>区别

    1、.sh文件
        .sh为linux的脚本文件，可以通过.sh执行一些命令，可以理解为windows的bat的批处理文件。

    二、.命令
        .命令和source是同一命令。
    三、sh/base/source/. 执行.sh文件的区别

        #!/bin/bash
        pidstat -d  1 > pidstat.txt

        假如有一个脚本test.sh
            echo "step 1 sleeping"
            sleep 200
            echo "step 2 sleeping"
            sleep 200

            1、./test.sh

            2、sh test.sh/bash test.sh

            3、. test.sh

            4、source test.sh
        区别是：
            第一种需要x权限，才能执行。如果中途停止，下面的不会执行。

            第二种是新建一个shell执行test.sh脚本里面的命令，不需要执行权限，有r 读取权限即可，有两个进程在运行，一个是bash，一个是sleep。如果中途终止，下面不会执行。
            提示:bash，是sh的加强版，sh相当于是bash的子集，效果基本一致。

            第三种只需要r 读取权限，不需要执行权限，只有一个新进程在运行sleep，如果终止会接着执行，直到结束。

            第四种和第三种一致。

# 17.后台运行

    只要在要执行的命令后面加上&就可以。

# 18.sudo

    切换用户名：
        su 用户名

# 19.nl

    nl用于计算文件中的行号。nl可以将输出的内容自动加上行号，其可以将行号做比较多的显示设计，包括位数和是否自动补0等等的功能。

    nl[选项]...[文件]...

>参数

    -b：指定行号的显示方式
        -b a 空行显示行号
        -b t 空行不显示行号
    -n:列出行号表示的方法
        -n ln 行号在屏幕的左方显示
        -n rn 行号在屏幕的右方显示不加0
        -n rz 行号在屏幕的左方显示加0
    -w:行号栏的占用的位数
    -p:在逻辑定界符不重新开始计算

    nl file.log 列出文件的内容，空行没有行号
    nl -b a -n rz 自动补0统一输出格式

    nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。

# 20.查看某个进程

    ps -mp <pid>

# 21.soure

    source ~/.zshrc 使文件立马生效

# 22.读取用户键入的值

    echo '请输入:'
    read input
    echo "输入的值为$input"

# 23.grep
```
grep 要搜索的内容 filePath
grep -E '1|2' 查询符合 1或者2的条件的内容
```
- cat filename | grep 'Filed' 时报Binary file (standard input) matches

```
cat filename | grep -a 'Filed' //可以加上-a进行特殊处理
```

# 24.awk sed Perlre
## 1.通过单个字符或者多个字符分隔字符串
- 注意：所有分割后的值都可以直接作为数组进行循环
>-F 参数

- 用:或者空格进行分隔字符串（或的关系）
```
// 
echo 'hello:world 123'|awk -F "[: ]" '{print $1" "$2" "$3}'
// 输出 hello world 123
```
- 用:/分隔字符串（并的关系）
```
echo 'hello:/world'|awk -F"[:][/]" '{print $1" "$2}'
// 输出 hello world
```
>split 参数

- awk的内建函数split运行把一个字符串分隔为单词并存储在数组中
- split(string,array,[field separator])
- split(string,array) // 默认FS值为空格
```
echo 'hello.world'|awk '{split($0,a,".");print a[1],a[2]}'
// 输出 hello world
```
>substr

- substr(s,p) 返回字符串s中从p开始的后缀部分
- substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分
```
echo '123456'|awk '{print substr($0,2)}'
// 输出 23456

echo '123456'|awk '{print substr($0,1,2)}'
// 输出 12
```
>FS 截取

```
echo 'hello:world'|awk 'BEGIN{FS=":"};{print $1};'
// 输出hello
```
>示例脚本

```
// 分隔字符串并循环打印所有的值
echo '210.12.5.222 222.72.140.114'|awk '{len=split($0,ipList," ");for(i=1;i<=len;i++) print ipList[i];}'
// 分隔字符串并打印第一个值
echo 'hello:world'|awk 'BEGIN{FS=":"} {print $1}'
```

## 2.sed
>去掉所有的双引号

```
echo '"hello world"'|sed 's/\"//g'
```
# 25.jq 解析字符串为json
```
echo '{"a":"1"}'|jq .
cat xx.json|jq .

location='{"data":{"ip":"110.12.112.12","country":"新西兰","region":"奥克兰","city":"奥克兰","isp":"未 >知"}}'
data=`echo $location|jq '.data'`
ip=`echo $data|jq '.ip'`
country=`echo $data|jq '.country'`
region=`echo $data|jq '.region'`
city=`echo $data|jq '.city'`
isp=`echo $data|jq '.isp'`
echo  "该ip:$ip 位于 $country $region $city $isp"

// 输出 该ip:"110.12.112.12" 位于 "新西兰" "奥克兰" "奥克兰" "未知"
```

# 26.rename

    重命名、批量重命名 支持正则表达式
    rename 's/$/.jpg/' * 把所有的文件后面加上.jpg

# 27.通过pid获取进程以及文件信息

    ll /proc/PID
    cwd 进程
    exe 路径

# 28.监听IO&监听 io 内存 cpu

    pidstat -d  1

    pidstat -u -r -d -t 1

# 29.更改文件的编码

    iconv -f 更改前encoding -t 更改后encoding inputfile

# 30.date

    date +%s
    获取时间戳 秒为单位

# 31.traceroute 追踪
    
    traceroute ip/域名
    
# 32.无挂起启动 nohup
    nohup Command &

# 33.zsh切换bash bash切换zsh
    
    切换bash

    chsh -s /bin/bash
    
    切换zsh

    chsh -s /bin/zsh
    
# 34.查询进程号 ps
    
    ps -ef|grep nginx

# 35.强制停止
    
    pkill -9 nginx

# 36.查看CPU    
    
    lscpu

# 37.清空history
    
    history -c 

# 38.清楚日志
    
    日志文件都在/var/log
    需要清除messages、以及secure

# 39.周期性执行某个命令
    
    watch [选项][参数]
>选项

    -n：指定指令执行的间隔时间（秒）；
    -d：高亮显示指令输出信息不同之处；
    -t：不显示标题。
>参数
    
    指令：需要周期性执行的指令。

# 40.sips Mac压缩图片
# 41.netstat
```
// 查询指定ip的链接内容
netstat -anp |grep ESTABLISHED|grep -E '172.96.194.164:16718|172.96.194.164:19997'

// 获取指定ip的相对应的ip
netstat -anp |grep ESTABLISHED|grep -E '172.96.194.164:16718|172.96.194.164:19997'|awk '{print $5}'|awk 'BEGIN{FS=":"} {print $1}'|sort|uniq
```
# 42.查询进程并杀死相关进程
```
ps -ef | grep "hexo" |grep -v grep|awk '{print $2}'|xargs kill -9
```
# 43.数组操作
>获取元素个数

```
numList=(1 2 3 4)
num=${#numList[@]} // 4
```
>获取数组的所有元素

```
numList=(1 2 3 4)
${numList[*]}
// 获取所有元素后就可以进行循环
for value in ${numList[*]}
do
    echo $value
done
// 输出 1 2 3 4
// 1 
// 2
// 3
// 4
```
# 44.变量运算
# 45.Centos 7服务注册、部署、开机自启
## 1.参数说明
```
[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别

[Service]部分是服务的关键，是服务的一些具体运行参数的设置.
Type=forking是后台运行的形式，
User=users是设置服务运行的用户,
Group=users是设置服务运行的用户组,
PIDFile为存放PID的文件路径，
ExecStart为服务的具体运行命令,
ExecReload为重启命令，
ExecStop为停止命令，
PrivateTmp=True表示给服务分配独立的临时空间
注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错

[Install]部分是服务安装的相关设置，可设置为多用户的
```

## 2.服务示例
- nginx
```
[Unit]
Description=nginx - high performance web server
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
Environment=PATH=/root/.nvm/versions/node/v12.8.1/bin:/usr/bin/v2ray/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf
ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf
ExecReload=/usr/sbin/nginx -s reload
ExecStop=/usr/sbin/nginx -s stop
ExecQuit=/usr/sbin/nginx -s quit
PrivateTmp=true

[Install]
WantedBy=multi-user.target

```

- pm2
```
[Unit]
Description=PM2 process manager
Documentation=https://pm2.keymetrics.io/
After=network.target

[Service]
Type=forking
User=root
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
Environment=PATH=/root/.nvm/versions/node/v12.8.1/bin:/usr/bin/v2ray/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
Environment=PM2_HOME=/root/.pm2
PIDFile=/root/.pm2/pm2.pid
Restart=on-failure

ExecStart=/root/.nvm/versions/node/v12.8.1/lib/node_modules/pm2/bin/pm2 resurrect
ExecReload=/root/.nvm/versions/node/v12.8.1/lib/node_modules/pm2/bin/pm2 reload all
ExecStop=/root/.nvm/versions/node/v12.8.1/lib/node_modules/pm2/bin/pm2 kill

[Install]
WantedBy=multi-user.target
```

## 3.常用命令

- 重新加载 systemd 程序的配置文件
```
sudo systemctl daemon-reload
```
- 启动服务
```
sudo systemctl start nginxReboot.service
```
- 停止服务
```
sudo systemctl stop nginxReboot.service
```
- 查看服务状态
```
systemctl status nginxReboot.service
```
- 设置开机自启
```
sudo systemctl enable nginxReboot.service
```
- 禁用开机自启
```
sudo systemctl disable nginxReboot.service
```
- 查看服务是否开机启动：
```
systemctl is-enabled nginxReboot.service
```
- 查看已启动的服务列表：
```
systemctl list-unit-files|grep enabled
```
- 掩盖服务禁止开机自启
```
sudo systemctl mask nginxReboot.service
```
## 4.注意的点
- centos 7用systemctl启动nginx后
- - 1.可能会出现 (13: Permission denied) while connecting to upstream:[nginx]
```
// 解决方法 执行下面的命令
setsebool -P httpd_can_network_connect 1
```
- - 2.可能会nginx: [emerg] BIO_new_file("/root/xxx/c...b
```
// 解决办法
// 需要把证书文件移动到nginx配置文件的地方 
比如我的证书在/root/xxx/xx.crt,需要移动到/etc/nginx/
```

# 46.lsmod 显示已载入系统的模块

>示例

```
lsmod | grep bbr
```
# 47.dig
# 48.while 循环
# 49.shell异步编程
## 1.sleep
- 等待进程（10秒）继续往下执行
```
sleep 10 node console.js # 等待10秒，再继续下一操作  
```
- 当前shell不等待，后台子shell等待
```
sleep 10 node console.js &
```

## 2.wait

- 1.等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。如果没有制定参数，则等待所有子进程的退出，其退出状态为0.
- 2.如果是shell中等待使用wait，则不会等待调用函数中子任务。在函数中使用wait，则只等待函数中启动的后台子任务。
- 3.在shell中使用wait命令，相当于高级语言里的多线程同步。

### 1.用法

```
wait [作业指示或进程号]
```
- 使用wait等待所有子任务结束
```
#!/bin/bash  
sleep 10 &  
sleep 5&  
wait #等待10秒后，退出  

#!/bin/bash  
sleep 10 &  
sleep 5&  
wait $! #$!表示上个子进程的进程号，wait等待一个子进程，等待5秒后，退出  

#!/bin/bash 
sleep 1 & echo 123 &
sleep 1 & echo 456 &
sleep 1 & echo 789 &
wait # 等待所有子进程结束后打印完成
echo '完成'
// 结果
// 123
// 456
// 789
// 完成
```
- 不等待直接异步执行
```
sleep 1 echo 123 &
sleep 1 echo 456 &
sleep 1 echo 789 &
```
#### 1.示例（结合node异步）等待子进程全部结束后打印完成

- console.js
```JavaScript
if(process.argv[2]==1){
  setTimeout(function(){
    console.log('1:',process.argv[2])
  },10000)
}else if(process.argv[2]==2){
  setTimeout(function(){
    console.log('2:',process.argv[2])
  },7000)
}else if(process.argv[2]==3){
  setTimeout(function(){
    console.log('3:',process.argv[2])
  },5000)
}else if(process.argv[2]==4){
  setTimeout(function(){
    console.log('4:',process.argv[2])
  },3000)
}
```
- sleep.*sh*
```
sleep 1  node console.js 1 &
sleep 1  node console.js 2 &
sleep 1  node console.js 3 &
sleep 1  node console.js 4 &
wait
echo '完成'
```
- 输出结果
```
4: 4
3: 3
2: 2
1: 1
完成
```
# 50.修改linux密码 
- 修改root密码 
```
// 执行 passwd

New password: 
Retype new password: 
按提示输入
```

- 修改其余用户密码
```
// 执行 passwd :用户名
passwd kook

New password:   
Retype new password:  
```
# 51.wc
- Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出
>命令参数

```
-c 统计字节数。

-l 统计行数。

-m 统计字符数。这个标志不能与 -c 标志一起使用。

-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。

-L 打印最长行的长度。

-help 显示帮助信息

--version 显示版本信息
```

# 52.复制到粘贴板
- Mac
```
echo 'pbcopy'|pbcopy 
```

# 53./usr/bin /usr/local/bin区别
- usr 指 Unix SystemResource，而不是User
- /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变
- usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。
- 如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响

# 54.You have new mail
- 由于系统错误（cron的权限问题）引起
- 系统会将检查的各种状态汇总，定期发送本机用户邮箱
- 删除可解决

## 1.查看
```
mail

Mail version 8.1 6/6/93.  Type ? for help.
"/var/mail/xxxx": 29 messages 29 new
>N  1 xx@xx.local     Fri Feb 23 10:39  21/954   "Cron <xx@xx> curl "http://localhost/t/cron.php" >>"
...
```
## 2.删除
- xxx对应上面看到的xxx的实际名称
```
sudo rm /var/mail/xxx
sudo touch /var/mail/xxx
```
# 54.linux修改DNS服务
```
1.编辑/etc/resolv.conf
2.添加  nameserver 8.8.8.8
3.执行 service network restart 重启网络服务
```
# 55.增加、删除虚拟内存
## 1.增加虚拟内存
- 1.获取文件块（具体划分多少swap交换分区，根据你的物理内存具体应用情况磁盘情况而定一般是物理内存的1~2倍）
```
dd if=/dev/zero of=swapfile bs=4096 count=1572864
```

- 2.创建swap文件
```
/sbin/mkswap -f swapfile
```

- 3.挂起swap文件
```
/sbin/swapon swapfile
```

- 4.检查swap是否正确
```
/sbin/swapon -s
```

- 5.加到fstab文件中让系统引导时自动启动
```
vi /etc/fstab
// 末尾加入
var/swapfile swap swap defaults 0 0
```
- 6.重启系统
```
reboot
```
- 7.挂载swapfile
```
swapon swapfile
```
- 8.查看swap交换分区情况
```
free -m
```
## 2.删除虚拟内存

# 56.dd命令

# 备注
>2019年6月5号

- 增加PATH地址详情地址格式
- 完善、增加 curl post请求方式
- 增加curl不显示统计信息
- 增加awk 分隔字符串详解
- 增加sed批量替换
- 增加jq解析字符串详情
- 增加netstat示例命令
- 增加查询进程并杀死相关进程的示例
- 增加数组操作

>2019年6月6号

- 增加scp指定端口 指定秘钥下载

>2019年6月12号

- 增加Centos7 服务注册

>2019年6月24日

- 增加lsmod相关内容

>2019年6月24日

- 增加dig、while循环

>2019年7月09日

- 增加shell异步编程 sleep、wait用法

>2019年7月16日

- 增加Linux修改密码

>2019年7月24日

- 增加wc统计使用方法
- 增加grep报错处理方法

>2019年8月15日

- 增加复制到粘贴板

>2019年8月16日

- /usr/bin /usr/local/bin区别

>2019年8月22日

- 增加curl不识别？等特殊字符问题

>2019年8月28日

- 增加You have new mail解决方案

>2019年9月4日

- 增加linux修改dns服务

>2019年9月26日

- 增加linux增加虚拟内存

>2019年10月09日

- 完善systemctl相关内容

>2019年10月10日

- systemctl增加注意的内容


>如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)
