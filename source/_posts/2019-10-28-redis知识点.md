---
layout: post
title: redis知识点
date: 2019-10-28
keywords: 
top: 10
categories: 
    - redis
tags:
    - redis
---
# redis知识点
# 1.概述
- Redis是完全开源免费的，遵守BDD协议，是一个高性能的key-value数据库。

## 1.相对于其他key-value DB的特点
- 1.Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载数据。
- 2.Redis不仅仅支持key-value类型的数据，同时还提供了list、set、zset、hash等数据结构的存储
- 3.Redis支持数据的备份，即master-slave模式的数据备份。

## 2.优势
- 性能极高。Redis能读的速度是110000次/s,写的速度是81000次/s 。
- 丰富的类型。Redis支持二进制案例的Strings、Lists、Hashes、Sets及Ordered Sets数据类型操作。
- 原子性。Redis的所有操作都是原子性的，意思就是要么执行成功要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，通过MULTI和EXEC指令包起来。

## 3.Redis与其他key-value存储有什么不同
- Redis有着为更为复杂的数据结构并提供原子性操作。
- Redis运行在内存中但是可以持久化到磁盘，所以在对不同的数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。
- 相对于磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样redis可以做很多内部复杂性很强的事情。在磁盘方面他们是紧凑的以追加的方式产生的，因此不需要进行随机访问。

# 2.redis key操作命令
- 用于管理redis的键

## 1.语法
```
redis 127.0.0.1:6379> COMMAND KEY_NAME
```
- 示例

```
redis 127.0.0.1:6379> SET test test
OK
redis 127.0.0.1:6379> DEL test
(integer) 1
```
## 2.Redis keys命令
命令|描述
-|-
DEL key|该命令用于在key存在时删除key
DUMP key|序列化给定key，并返回被序列化的值
EXISTS key|检查key是否存在
EXPIRE key seconds|给定key设置过期时间，单位秒
EXPIREAT key timestamp|EXPIREAT的作用和EXPRIR类型，用于key的设置过期时间。不同在于EXPIREAT命令接受的时间参数是UNIX时间戳（unix timestamp）
PEXPRIE key milliseconds|设置key的过期时间以毫秒计。
KEYS pattern|查找所有符合给定模式（pattern）的key
MOVE key db|将当前数据库的key移动到给定的数据库DB当中
PERSIST key|移除key的过期时间，key将持久保持。
PTTL key|以毫秒为单位返回key的剩余的过期时间。
TTL key|以秒为单位，返回给定key的剩余生存时间（TTL time to live）
RANDOMKEY|从当前数据库中随机返回一个
RENAME key newkey|修改key的名称
RENDMENX key newkey|仅当newkey不存在时，将key改为newkey
TYPE key|返回key所存储的值的类型。

# 3.数据类型
- string（字符串）、hash（哈希）、list（列表）、set（集合）zset（sorted set：有序集合）。

## 2.string(字符串)
- string是一个redis最基本的类型，可以理解为Memcached一模一样的类型，一个key对应一个value。
- string类型是二进制安全的。redis的string可以包含任何数据。比如jpg图片或者序列化的对象。
- string类型是Redis最基本的数据类型，string类型的值最大能存储512MB。

### 1.语法
- 基本语法
```
127.0.0.1:6379>COMMAND KEY_NAME
```
- 设置一个key为test，value为 test的键值对
```
127.0.0.1:6379> set test test
OK

// 取出
127.0.0.1:6379> get test
"test"
```
### 2.常用命令
命令|描述
-|-
SET key value|设置指定key的值
GET key|获取指定的key值
GETRANGE key start end|返回key中字符串值的子字符(截取)
GETSET key value|将给定key的值设为value，并返回key的旧值（old value）
GETBIT key offset|将key说存储的字符串子，获取指定偏移量上的位（bit）
MGET key1[key2...]|获取所有（一个或多个）给定的key的值
SETBIT key offset value|对key说存储的字符串值，设置或者清楚指定偏移量上的位（bit）
SETNX key value|只有在key不存在时设置key的值
SETRANGE key offset value|用value参数覆写给定key所存储的字符串值，从偏移量offset开始。
STRLEN key|返回key所存储的字符串值的长度
MSET key value[key value]|同时设置一个或多个key-value对。
MSETNX key value [key value....]|同时设置一个或者多个key-value对。
PSETEX key milliseconds value|这个命令和SETEX命令相似，但它以毫秒为单位设置key的生存空间，而不是像SETEX命令那样，以秒为单位。
INCR key|将key中存储的数字值增1
INCRBY key increment|将key所存储的值加上给定的增量值（increment）。
INCRBYFLOAT key increment|将key所存储的值加上给定的浮点增量值（increment）
DECR key|将key中存储的数字值减一。
DECRBY key decrement|key所存储的值减去给定的减量值（decrement）。
APPEND key value|如果key已经存在并且是一个字符串，APPEND命令将指定的value追加到该key原来值（value）的末尾。

## 2.哈希（Hash）
- hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
- redis每个hash可以存储2的32次方 - 1 个键值对（40多亿）

### 1.示例
```
127.0.0.1:6379> HMSET test2 name 'key' value value
OK
127.0.0.1:6379> HGET test2 name
"key"
127.0.0.1:6379> HMSET hashTest name hashTest value abcd
OK
127.0.0.1:6379> HGETALL hashTest
1) "name"
2) "hashTest"
3) "value"
4) "abcd"
127.0.0.1:6379> HGET hashTest value
"abcd"
```
### 2.hash命令

命令|描述
-|-
HDEL key field1 [field2]|删除一个或多个哈希表字段
HEXISTS key field|查看哈希表中，指定的key是否存在
HGET key field|获取存储在哈希表中指定字段的值
HGETALL key|获取在哈希表中指定key的所有字段和值
HINCRBY key field increment|为哈希表key中的指定字段的整数值加上增量increment
HINCRBYFLOAT key field increment|为哈希表key中的指定字段的浮点数值加上增量increment
HKEYS key|获取所有哈希表中的字段
HLEN key|获取hash表中的key的数量
HMGET key filed1 [field2....]|获取所有给定字段的值
HMSET key field1 value1 [field2 value2]|同时将多个field-value（域-值）对设置到哈希表key中。
HSET key field value|将哈希表key中的字段field的值设为value
HSETNX key field value|只有在字段不存在时，设置哈希表中的值
HVALS key|获取哈希表中所有值
HSCAN key cursor [MATCH pattern] [COUNT count]|迭代哈希表中的键值对

## 3.列表（List）
- Redis列表是简单的字符串列表，按照插入顺序排序。
- 可以添加一个元素到列表的头部（左边）或者尾部（右边）
- 一个列表最多包含2的32次方-1个元素（4294967295, 每个列表超过40亿个元素）

### 1.示例
- testList 插入key为testList的三个值
```
127.0.0.1:6379> lpush testList test1
(integer) 1
127.0.0.1:6379> lpush testList test2
(integer) 2
127.0.0.1:6379> lpush testList test3
(integer) 3
127.0.0.1:6379> LRANGE testList 0 10
1) "test3"
2) "test2"
3) "test1"
```
### 2.列表相关命令
命令|描述
-|-
BLPOP key1 [key2] timeout|移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出的元素为止
BRPOP key1 [key2] timeout|移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或者发现可弹出元素为止
BRPOPLPUSH source destination timeout|从列表中弹出一个值，将弹出的元素插入到另一个列表并返回它；如果列表没有元素会阻塞列表直到等待超时或发现可弹出的元素为止。
LINDEX key index|通过索引获取列表的元素
LINSERT key BEFORE\|AFTER pivot value|在列表的元素前或者后插入元素
LLEN key|获取列表的长度
LPOP key|移除并获取列表的第一个元素
LPUSH key value1[value2]|将一个或者多个值插入到列表的头部
LPUSHX key value|将一个值插入到已存在的列表头部
LRANGE key start stop|获取列表指定范围内的元素
LREM key count value|移除列表元素
LSET key index value|通过索引设置列表元素的值
LTRIM key start stop|对一个列表进行修剪（trim），就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
RPOP key|移除列表最后一个元素，并返回
RPOPLPUSH source destination|移除列表的最后一个元素，并将该元素添加到另一个列表并返回
RPUSH key value1 [value2]|在列表中添加一个或多个值
RPUSHX key value|为已存在的列表添加值

## 4.集合（Set）
- Set是string类型的无序组合。
- Set成员是唯一的，不能出现重复值。
- Set是通过hash实现的，所以添加、删除、查找的复杂度都是O(1)
- Set中最大的成员数为2的三十二次方-1（4294967295, 每个集合可存储40多亿个成员）

### 1.示例
- 添加key为test的若干值
```
127.0.0.1:6379> SADD test 1
(integer) 1
127.0.0.1:6379> SADD test 2
(integer) 1
127.0.0.1:6379> SADD test 3
(integer) 1
127.0.0.1:6379> SADD test 4
(integer) 1
127.0.0.1:6379> SMEMBERS test
1) "1"
2) "2"
3) "3"
4) "4"
```
### 2.Set命令
命令|描述
-|-
SADD key member1 [member2]|向集合添加一个或多个成员
SCARD key|获取集合的成员数
SDIFF key1 [key2]|返回给定所有集合的差集
SDIFFSTORE destination key1 [key2]|返回给定所有集合的差集并存储在destination中
SINTER key1 [key2]|返回给定所有集合的交集
SINTERSTORE destination key1 [key2]|返回给定所有集合的交集并存储在destination中
SISMEMEBER key member|判断member元素是否是集合key的成员
SMEMBERS key|返回集合中所有成员
SMOVE source destination member|将member元素从source集合移动到destination集合
SPOP key|移除并返回集合中的一个随机元素
SRANDMEMBER key [count]|返回集合中一个或多个成员
SUNION key1 [key2]|返回所有给定集合的并集
SUNIONSTORE destination key1 [key2]|所有给定集合的并集存储在destination 集合中
SSCAN key cursor [MATCH pattern] [COUNT count]|迭代集合中的元素

## 5.有序集合（sorted set）
- redis有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。
- 不同得是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
- 有序集合的成员是唯一的，但是分数（score）却可以重复
- 集合是通过哈希表实现的，所有添加删除查找都是O(1)。
- 有序集合最大的成员数为2的三十二次方-1（4294967295, 每个集合可存储40多亿个成员）

### 1.示例
- 通过ZADD向redis有序集合中添加三个值并关联分数
```
127.0.0.1:6379> zadd test 1 test1
(integer) 1
127.0.0.1:6379> zadd test 2 test2
(integer) 1
127.0.0.1:6379> zadd test 3 test3
(integer) 1
127.0.0.1:6379> zadd test 4 test4
(integer) 1
127.0.0.1:6379> zrange test 0 10 withscores
1) "test1"
2) "1"
3) "test2"
4) "2"
5) "test3"
6) "3"
7) "test4"
8) "4"
```
### 2.redis有序集合命令
命令|描述
-|-
ZADD key score1 member1 [score2 member2]|向有序集合添加一个或多个成员，或者更新已存在成员的分数
ZCARD key|获取有序集合的成员数
ZCOUNT key min max|计算在有序集合中指定区间分数的成员数
ZINCRBY key increment member|有序集合中对指定成员的分数加上增量increment
ZINETERSTORE destination numkeys key [key ...]|计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合key中
ZLEXCOUNT key min max|在有序集合中指定字典区间内成员数量
ZRANGE key start stop [WITHSCORES]|通过索引区间返回有序集合指定区间内的成员
ZRANGEBYLEX key min max [LIMIT offset count]|通过字典区间返回有序集合的成员
ZRANGEBYSCORE key min max [WITHSCORES][LIMIT]|通过分数返回有序集合指定区间内的成员
ZRANK key member|返回有序集合中指定成员的索引
ZREM key member[member...]|移除有序集合中的一个或多个成员
ZREMRANGEBYLEX key min max|移除有序集合中给定的字典区间的所有成员
ZREMRANGEBYRANK key start stop|移除有序集合中给定的排名区间的所有成员
ZREMRANGEBYSCORE key min max|移除有序集合中给定的分数区间的所有成员
ZREVRANGE key start stop [WITHSCORES]|返回有序集合中指定区间内的成员，通过索引，分数从高到低
ZREVRANGEBYSCORE key max min [WITHSCORES]|返回有序集合中指定分数区间内的成员，分数从高到低排序
ZREVRANK key member|返回有序集合中指定成员的排名，有序集合按分数值递减（从大到小）排序
ZSCORE key member|返回有序集合中，成员的分数值
ZUNIONSTORE destination numkeys key [key...]|计算给定的一个或者多个有序集的并集，并存储在新的key中
ZSCAN key cursor [MATCH pattern][COUNT cout]|迭代有序集合中的元素（包含元素成员和元素分值）

# 4.HyperLogLog
- 2.8.9添加了HyperLogLog结构
- 用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。
- 每个HyperLogLog键只需要花费12kb内存，就可以计算出接近2^64个不同元素的基数。这和计算基数时，元素越多消耗内存就越多形成鲜明对比。
- 因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不像集合那样，返回输入的各个元素。

## 1.什么是基数
- 比如数据集{1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为{1, 3, 5 ,7, 8}, 基数（不重复元素）为5。基数估计就是在误差可接受的范围内，快速基数。


## 2.示例
- 工作过程
```
127.0.0.1:6379> PFADD test test1
(integer) 1
127.0.0.1:6379> PFADD test test2
(integer) 1
127.0.0.1:6379> PFADD test test3
(integer) 1
127.0.0.1:6379> PFADD test test4
(integer) 1
127.0.0.1:6379> PFCOUNT test
(integer) 4
```

## 3.HyperLogLog命令
命令|描述
-|-
PFADD key element [element...]|添加指定元素到HyperLogLog中
PFCOUNT key [key...]|返回给定HyperLogLog的基数估算值
PFMERGE destkey sourcekey [sourcekey...]|将多个HyperLogLog合并为一个HyperLogLog

# 5.发布订阅
- 发布订阅（pub/sub）是一种消息通信模式：发布者（pub）发送消息，订阅着（sub）接受消息。
- 可以订阅任意数量的频道
- 下图展示了频道channel1，以及订阅这个频道的三个客户端--client2、client5和client1之间的关系
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/redis/pubsub1_channel1.png' width=300/>

- 当有新消息时PUBLISH命令发送给频道channel1时，这个消息会被发送给订阅它的三个客户端
<img src='https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/redis/pubsub2_channel1.png' width=300/>

## 1.示例
- 创建名为redisChat的频道
```
redis 127.0.0.1:6379> SUBSCRIBE redisChat

Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "redisChat"
3) (integer) 1
```
- 重新开启一个新redis客户端，然后在同一个频道redisChat发布消息，订阅着则能收到消息
```
redis 127.0.0.1:6379> PUBLISH redisChat "Redis is a great caching technique"

(integer) 1

redis 127.0.0.1:6379> PUBLISH redisChat "Learn redis by runoob.com"

(integer) 1

# 订阅者的客户端会显示如下消息
1) "message"
2) "redisChat"
3) "Redis is a great caching technique"
1) "message"
2) "redisChat"
3) "Learn redis by runoob.com"
```
## 2.发布订阅命令
命令|描述
-|-
PSUBSCRIBE pattern [pattern...]|订阅一个或者多个符合给定模式的频道
PUBSUB subcommand [argument [argument...]]|查看订阅与发布系统状态
PUBLISH channel message|将消息发送到指定的频道
PUNSUBSCRIBE [pattern [pattern...]]|退订所有给定模式的频道
SUBSCRIBE channel [channel...]|订阅给定的一个或者多个频道的信息
UNSUBSCRIBE [channel [channel...]]|退订指定的频道

# 6.事务
- redis事务可以再一次执行多个命令，并带有是哪个重要的保证
- - 批量操作在放松exec命令前被放入队列缓存
- - 受到exec命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- - 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。

- 一个事务从开始到执行要经历三个阶段
- - 开始事务
- - 命令入队
- - 执行事务

## 1.示例
- MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务，一并执行事务中的所有命令
```
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set test1 'test1'
QUEUED
127.0.0.1:6379> get test1
QUEUED
127.0.0.1:6379> sadd tag 'test2' 'test3' 'test4'
QUEUED
127.0.0.1:6379> smembers tag
QUEUED
127.0.0.1:6379> exec
1) OK
2) "test1"
3) (integer) 3
4) 1) "test4"
   2) "test3"
   3) "test2"
```
- 单个redis命令执行是原子性的，但redis没有在事务上增加任何原子性的机制，所以redis事务的执行并不是原子性的。
- 事务可以理解我一个打包的批量执行脚本，但批量指令并非原子化操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不执行。

## 2.事务命令
命令|描述
-|-
discard|取消事务，放弃执行事务块内的所有命令
exec|执行一个事务块内的命令
multi|标记一个事务块的开始。
unwatch|取消watch命令对所有key的监视
watch key [key...]|监视一个或者多个key，如果在事务执行之前这个或这些key被其他命令说改动，那么事务将被打断。

>如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)

# 备注
>2019年10月29日

- 增加数据类型 List、Set、sorted set

>2019年11月01日

- 增加数据类型 发布订阅

