---
layout: post
title: Docker知识点【更新中】
date: 2019-12-25
keywords:
top: 10
categories:
    -
tags:
    -
---
# Docker知识点
## Docker中午学习网站
- [Docker中文学习网站[yeasy]](https://legacy.gitbook.com/book/yeasy/docker_practice/details)
- [Docker中文学习网站[runoob]](https://www.runoob.com/docker/docker-tutorial.html)

# 1.安装
## 1.Debian
- 1.更新包列表
```
sudo apt update
```
- 2.安装必备包
```
sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common
```
- 3.将官方Docker存储库的GPG密钥添加到系统
```
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
```

- 4.将Docker存储库添加到APT源
```
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable"
```
- 5.确保要从Docker repo而不是默认的Debian repo安装
```
apt-cache policy docker-ce

#

docker-ce:
  Installed: (none)
  Candidate: 18.06.1~ce~3-0~debian
  Version table:
     18.06.1~ce~3-0~debian 500
        500 https://download.docker.com/linux/debian stretch/stable amd64 Packages

请注意，未安装docker-ce ，但安装的候选者来自Debian 9的Docker存储库（ stretch ）
```
- 6.安装Docker
```
sudo apt install docker-ce
```

- 7.守护进程&开机自启&启动
```
# 查看状态
sudo systemctl status docker

# 开机自启动
sudo systemctl enable docker

# 启动docker
sudo systemctl start docker

# 关闭docker
sudo systemctl stop docker
```

## 2.CentOS
- 1.卸载旧版
```
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```
- 2.安装Docker Engine-Community。新主机上首次安装Docker Engine-Community之前，需要设置Docker仓库。之后可以从仓库更新和安装Docker。安装所需软件包。
```
sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
```

- 3.设置稳定仓库
```
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
```

- 4.安装Docker Engine-Community和containerd（默认最新）
```
sudo yum install docker-ce docker-ce-cli containerd.io
```

- 5.守护进程&开机自启&启动
```
# 查看状态
sudo systemctl status docker

# 开机自启动
sudo systemctl enable docker

# 启动docker
sudo systemctl start docker

# 关闭docker
sudo systemctl stop docker
```
# 2.Dockerfile
## 1.COPY 复制文件
- 根据上下文目录copy文件或者文件夹
### 1.格式
```
COPY [--chown=<user>:<group>] <源路径>... <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",..."<目标路径>"]
```
- 源路径可以有多个，也可以是通配符
- 通配符需要满足GoLang的filepath.Match规则
```
COPY index* /mydir/
COPY inde?.txt /mydir/
```
### 2.其余注意事项
- <目标路径>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（WORKDIR指定的路径）。
- 目标目录不需要事先创建，如果目录不存在会在复制文件前创建相应的目录。
- COPY指令，源文件的各种元数据都会保留。读、写、执行权限、文件变更时间等

### 3.设置用户以及用户组
```
COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
```

## 2.ADD 更高级的复制文件
- 与COPY功能基本相同
- <源路径>可以是一个URL，这种情况下，Docker引擎会试图去下载这个链接的文件放到<目标路径>。
- 下载后的文件权限自动设置为600.
- 如果下载的是个压缩包，需要解压缩，还是需要RUN命令来进行解压缩，但是如果<源路径>为一个tar压缩文件，压缩格式为gzip、bzip2、xz的情况下，ADD指令会自动解压缩这个压缩文件到<目标路径>去。
- 尽可能使用COPY指令，COPY语义明确，只有拷贝文件和文件夹的功能。
- ADD指令会令镜像构建缓存失效，从而可能会令镜像构建变的比较缓慢。
- 改变文件的所属用户以及所属组
```
ADD --chown=55:mygroup files* /mydir/
ADD --chown=bin files* /mydir/
ADD --chown=1 files* /mydir/
ADD --chown=10:11 files* /mydir/
```

## 3.CMD容器启动指令
- Docker不是虚拟机，容器中的主应用应该在前台运行，容器中没有后台服务的概念。
- 容器即进程

### 1.格式
- shell格式
```
CMD <命令>
```

- exec 格式
```
CMD ["可执行文件","参数1","参数2"...]
```

- Nginx 示例
```
CMD ["nginx", "-g", "daemon off;"]
```

## 4.ENTRYPOINT 入口点
- ENTRYPOINT的格式和RUN指令格式一样，分为exec格式和shell格式。
- ENTRYPOINT的目的和CMD一样，都是指定容器启动程序以及参数
- ENTRYPOINT在运行时也可以替代，不过比CMD要略显繁琐，需要dokcer run的参数--entrypoint指定。
- 当指定了ENTRYPOINT后，CMD的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令，换句话说实际执行时，将变为
```
<ENTRYPOINT> "<CMD>"
```
### 1.场景一：让镜像变成像命令一样使用
- 假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：
```
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
CMD [ "curl", "-s", "https://ip.cn" ]
```
- 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：

```
$ docker run myip
当前 IP：xx.xxx.226.xx 来自：北京市 联通
```

- 如果我们希望增加一个参数呢，比如上面的curl命令显示HTTP头信息，就需要加上 -i参数。那么我们可以很直接加-i参数给docker run myip吗
```
$ docker run myip -i
docker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n".
```
- 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s https://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。
- 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令
```
docker run myip curl -s https://ip.cn -i
```

- 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：
```
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "https://ip.cn" ]
```
- 这次我们再来尝试直接使用 docker run myip -i：
```
$ docker run myip -i
HTTP/1.1 200 OK
Server: nginx/1.8.0
Date: Tue, 22 Nov 2016 05:12:40 GMT
Content-Type: text/html; charset=UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006
Connection: keep-alive

当前 IP：xx.xxx.226.xx 来自：北京市 联通

可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果

```


### 2.场景二：应用运行前的准备工作
- 启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。
- 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。
- 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。
- 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <CMD>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：
```
FROM alpine:3.4
...
RUN addgroup -S redis && adduser -S -G redis redis
...
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD [ "redis-server" ]
```

- 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。
```
#!/bin/sh
...
# allow the container to be started with `--user`
if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then
    chown -R redis .
    exec su-exec redis "$0" "$@"
fi

exec "$@"
```
- 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：
```
$ docker run -it redis id
uid=0(root) gid=0(root) groups=0(root)
```

## 5.ENV
- ENV代表环境变量，无论后面什么命令，如RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。
### 1.格式
```
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2>...
```
### 2.使用
- 也可以在CMD运行脚本的时候在脚本中使用
```
# Dockerfile
ENV NODE_VERSION 10.1.0
RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \

# CMD脚本使用
echo $PUBLISH_HOST
```
- 启动时使用
```
docker build --build-arg PUBLISH_HOST=aValue
```

## 6.ARG 构建参数
- 格式
```
ARG <参数名>[=<默认值>]
```

- 示例
```
# 启动时使用--build-arg覆盖
# Dockerfile
ARG PUBLISH_HOST=default        # 可设置默认值
ENV PUBLISH_HOST $PUBLISH_HOST  # 保证传递参数是可以被ARG的覆盖

# 启动命令
docker build --build-arg PUBLISH_HOST=aValue

# 脚本中正常获取即可
echo $PUBLISH_HOST
```

## 7.VOLUME 定义匿名卷
- 格式
```
VOLUME ["<路径>","<路径2>"...]
VOLUME <路径>
```
- 容器运行时应该尽量避免发生写入操作，对于数据库雷需要保存的数据，应保存到卷（volume）中

- 示例
```
# -v 指定匿名卷地址

docker run -d -v mydata:/data xxxx
```

## 8.EXPOSE声明端口
- EXPOSE指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。
- Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以便配置映射。
- 另一个用处这是在运行实用随机端口映射时，也就是docker run -P时，会自动随机映射EXPOSE端口。

- 格式
```
EXPOSE <端口1>[<端口2>...]
```

## 9.WORKDIR指定工作目录
- 使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改成指定的目录，如果目录不存在WORKDIR会帮你建立目录。
- 格式
```
WORKDIR <工作目录路径>
```
- 初学者还会把Dockerfile当成Shell脚本来写，可能会出现这样的错误
- 这种错误是对Dockerfile构建分层存储的概念不了解导致的，每执行一个指令都是启动一个容器。
- 在Docker中两个RUN命令的执行环境根本不同，是两个完全不同的容器，所以可能到不到想要的效果
```
RUN cd /app
RUN echo 'hello' > world.txt

# 下面这个写法可以正确执行
RUN cd /app && RUN echo 'hello' > world.txt
```

## 10.USER指定当前用户
- USER是帮你切换到指定用户，这个用户必须事先建立好，否则无法切换。
- USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。
- WORKDIR是改变工作目录，USER则是改变之后层的执行RUN，CMD以及ENTRYPOINT这类命令的身份。

- 格式
```
USER <用户名>[:<用户组>]
```

- 示例
```
RUN groupadd -r redis && useradd -r -g redis redis
USER redis
RUN [ "redis-server" ]
```

- 如果以root执行脚本，在执行期间希望改变身份，不要使用su或者sudo，都需要比较麻烦的配置。
- 在TTY缺失的环境下经常出错。建议使用gosu
- 示例
```
# 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis && useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64" \
    && chmod +x /usr/local/bin/gosu \
    && gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ "exec", "gosu", "redis", "redis-server" ]
```

# 3.镜像托管
## 1.[Docker Hub](hub.docker.com)
### 1.Github账号连接到Docker Hub

- 打开 [Docker Hub](hub.docker.com) -> 登录 -> 点击Create -> 选择 Create Automated Build -> Linked Accounts -> Link Github -> Public and Private (Recommended) -> Authorize application -> 输入 Github 密码

### 2.自动构建
- 打开 [Docker Hub](hub.docker.com) -> 登录 -> 点击Create -> 选择 Create Automated Build -> 选择Github -> 选择仓库 -> 设置镜像名、描述、public 还是 private -> create -> 在 Build Settings 里选择分支、设置Dockerfile的地址、设置每次构建的标签 -> 更新github仓库，触发自动构建 -> 查看构建详情

# 4.容器间互相访问
- 1.可以通过设置link
- 2.开放对外端口

### 1.启动mysql，同时开放了9333对外端口
```
docker run --name v2ray-mysql -e MYSQL_ROOT_PASSWORD=admin -d -p 9333:3306 mysql mysqld --default-authentication-plugin=mysql_native_password
```

### 2.其余容器访问
- 启动容器
```
docker run -d -p 9001:80 --link v2ray-mysql
```

- link方式连接mysql
```
# 这里 --link了mysql容器的name
# 配置文件中可以按照下方的内容进行配置

host: 'v2ray-mysql',
user: 'root',
password: 'admin',
database: 'test',
port: 3306
```

- 对外端口方式
```
# 启动容器去掉link即可
# 配置文件中可以按照下方的内容进行配置

host: 'ip',
user: 'root',
password: 'admin',
database: 'test',
port: 9333
```
## 2.其余设置解析
- 示例命令
```
docker run --name test-mysql -e MYSQL_ROOT_PASSWORD=admin -d -p 9333:3306 mysql mysqld --default-authentication-plugin=mysql_native_password -e TZ=Asia/Shanghai

--name test-mysql                     # 给mysql取名
-e  MYSQL_ROOT_PASSWORD=newPassword   # 初始化默认密码
-d                                    # 后台启动
-p 9333:3306                          # 宿主机端口:内部端口
mysqld --default-authentication-plugin=mysql_native_password # 兼容mysql模块并未完全支持MySQL 8的caching_sha2_password加密
-e TZ=Asia/Shanghai                   # 修改为上海的时区
```

# 常见错误
## 1.docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "process_linux.go:430: container init caused \"write /proc/self/attr/keycreate: permission denied\"": unknown.
- 1.修改下面文件SELINUX的值为disabled，然后重启
```
/etc/selinux/config
```
>如有侵权行为，请[点击这里](https://github.com/cooper-q/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/cooper-q/MattMeng_hexo/issues)

# 备注

