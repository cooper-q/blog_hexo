---
layout: post
title: ECMAScript6、7、8整理
date: 2019-07-18
keywords: 
top: 10
categories: 
    - JavaScript
    - ECMAScript
tags:
    - JavaScript
    - ECMAScript
---
# ECMAScript6、7、8整理
# 1.let
- let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。
- let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，let声明的变量只能是全局或者整个函数块的。
- let声明的变量只在其声明的块或子块中可用
- let与var主要的区别在于var声明的变量的作用域是整个封闭函数。

>语法

```
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
```

>参数

```
var1, var2, …, varN
变量名。必须是合法的标识符。

value1, value2, …, valueN
变量的初始值。可以是任意合法的表达式。
```
## 1.重复声明

- 在同一个函数或块作用域中重复声明同一个变量会引起SyntaxError。

```JavaScript
if (x) {
  let foo;
  let foo; // SyntaxError thrown.
}
```
>switch

- 因为switch只有一个作用块。所以在一个switch中不可声明同一命名的变量。
- 可以通过对case后面创建新的块作用域，形成新的词法环境。

```
// error

switch(x){
    case 0:
        let foo;
        break;
    case 1:
        let foo;    // SyntaxError for redeclaration
        break; 
}

// success

switch(x){
    case 0:{
        let foo;
        break;
    }
    case 1:{
         let foo;    
         break;
    }
}
```

## 2.暂存死区（暂时性死区（TDZ））

- let 被创建在包含该声明的（块）作用域顶部，一般被称为“提升”。
- 通过  var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。
- 在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

```
function do_something() {
  console.log(bar); // undefined
  console.log(foo); // ReferenceError
  var bar = 1;
  let foo = 2;
}
```

> let后跟一个函数传递的参数时将导致循环内部报错。

```
// 因为let n of n.a 是一个作用域 未声明调用 
function go(n){
  for (let n of n.a) { // ReferenceError: n is not defined
    console.log(n);
  }
}

go({a:[1,2,3]});

// 与之var对比
function go(n){
    for (var n of n.a) {
        console.log(n); // 1 2 3
    }
}

go({a:[1,2,3]});

```

>循环定义中的let作用域

```
var i=0;
for(let i=i;i<10;i++){ // i is not defined
    console.log(i);
}

for(let expr1;expr2;expr3) statement
这个例子中expr1、expr2、expr3、statement都包含再一个隐含域块中。
```

## 3.块级作用域

>利用块级作用域声明同样名称的变量名

```
let a='1';
function a(){
    let a='2';
    console.log(a);//2
    if(true){
        let a='3';
        console.log(a);//3
    }
}
```
>利用块级作用域声明函数

- 声明函数相当于let声明方法，所以有块级作用域，可以重复声明，只有在有大括号的情况下可以声明。
- 在处理构造函数时就可以直接使用let而不是用闭包来创建私有变量

```
function func(){
    if(true){
        function a(){
            console.log(1);//1
        }
        a();
    }
}

```

## 3.总结

- let只在他所在代码块有效。
- 不存在变量提升，必须先声明后使用
- 暂时性死区。TDZ 不受外部影响。（函数外与函数内可以声明统一命名的变量）
- do表达式


# 2.const
    
- 一旦声明变量不允许改变。
- 并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
- 对于简单类型的数据，值就是指向的那个内存地址，因此等于常量。
- 只能保证指针是固定的，至于他指向的数据结构是不是可变的，就不能完全控制了，所以可以用作统计count之类的东西。是没有变量提升的。
- let的暂存死区同样适用于const
- 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

```
const a={
    count:0
}
function b(){
    a.count=a.count+1;
}

作用域也是块级作用域。
```

>声明变量的六种方法

```
// ES5:

var function

// ES6:

let const import class
```

>顶层的对象的属性

```
浏览器: window对象
Node:global
es5，全局变量就是顶层对象。
es6，全局变量逐步与顶层对象的属性脱钩。
```

>如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)

# 备注

