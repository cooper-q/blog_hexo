---
layout: post
title: ECMAScript6、7、8整理
date: 2019-07-18
keywords: 
top: 10
categories: 
    - JavaScript
    - ECMAScript
tags:
    - JavaScript
    - ECMAScript
---
# ECMAScript6、7、8整理
# 1.let
- let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。
- let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，let声明的变量只能是全局或者整个函数块的。
- let声明的变量只在其声明的块或子块中可用
- let与var主要的区别在于var声明的变量的作用域是整个封闭函数。

>语法

```
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
```

>参数

```
var1, var2, …, varN
变量名。必须是合法的标识符。

value1, value2, …, valueN
变量的初始值。可以是任意合法的表达式。
```
## 1.重复声明

- 在同一个函数或块作用域中重复声明同一个变量会引起SyntaxError。

```JavaScript
if (x) {
  let foo;
  let foo; // SyntaxError thrown.
}
```
>switch

- 因为switch只有一个作用块。所以在一个switch中不可声明同一命名的变量。
- 可以通过对case后面创建新的块作用域，形成新的词法环境。

```
// error

switch(x){
    case 0:
        let foo;
        break;
    case 1:
        let foo;    // SyntaxError for redeclaration
        break; 
}

// success

switch(x){
    case 0:{
        let foo;
        break;
    }
    case 1:{
         let foo;    
         break;
    }
}
```

## 2.暂存死区（暂时性死区（TDZ））

- let 被创建在包含该声明的（块）作用域顶部，一般被称为“提升”。
- 通过  var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。
- 在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

```
function do_something() {
  console.log(bar); // undefined
  console.log(foo); // ReferenceError
  var bar = 1;
  let foo = 2;
}
```

> let后跟一个函数传递的参数时将导致循环内部报错。

```
// 因为let n of n.a 是一个作用域 未声明调用 
function go(n){
  for (let n of n.a) { // ReferenceError: n is not defined
    console.log(n);
  }
}

go({a:[1,2,3]});

// 与之var对比
function go(n){
    for (var n of n.a) {
        console.log(n); // 1 2 3
    }
}

go({a:[1,2,3]});

```

>循环定义中的let作用域

```
var i=0;
for(let i=i;i<10;i++){ // i is not defined
    console.log(i);
}

for(let expr1;expr2;expr3) statement
这个例子中expr1、expr2、expr3、statement都包含再一个隐含域块中。
```

## 3.块级作用域

>利用块级作用域声明同样名称的变量名

```
let a='1';
function a(){
    let a='2';
    console.log(a);//2
    if(true){
        let a='3';
        console.log(a);//3
    }
}
```
>利用块级作用域声明函数

- 声明函数相当于let声明方法，所以有块级作用域，可以重复声明，只有在有大括号的情况下可以声明。
- 在处理构造函数时就可以直接使用let而不是用闭包来创建私有变量

```
function func(){
    if(true){
        function a(){
            console.log(1);//1
        }
        a();
    }
}

```

## 3.总结

- let只在他所在代码块有效。
- 不存在变量提升，必须先声明后使用
- 暂时性死区。TDZ 不受外部影响。（函数外与函数内可以声明统一命名的变量）
- do表达式


# 2.const
    
- 一旦声明变量不允许改变。
- 并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
- 对于简单类型的数据，值就是指向的那个内存地址，因此等于常量。
- 只能保证指针是固定的，至于他指向的数据结构是不是可变的，就不能完全控制了，所以可以用作统计count之类的东西。是没有变量提升的。
- let的暂存死区同样适用于const
- 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

```
const a={
    count:0
}
function b(){
    a.count=a.count+1;
}

作用域也是块级作用域。
```

>声明变量的六种方法

```
// ES5:

var function

// ES6:

let const import class
```

>顶层的对象的属性

```
浏览器: window对象
Node:global
es5，全局变量就是顶层对象。
es6，全局变量逐步与顶层对象的属性脱钩。
```
# 3.Set
- Set 可以去从但是适用于数组或者类似数组的对象作为参数，去从限制在同类型之间。
- Set加入值得时候，不会发生类型转换，所以5和'5'是两个不同的值,使用===来判断。
- 两个对象总是不相等的，因为地址不同。地址为唯一标识。
- NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。

```
const s = new Set([1,2,3,4,4]);// 1,2,3,4 
```
## 1.参数
- iterable，如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空

## 2.描述
- Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。

## 3.属性

- size 成员总数
- constructor 构造函数

## 4.方法

- <span style='color:red'>add</span>       添加某个值，返回Set结构本身。
- <span style='color:red'>delete</span>   删除某个值，返回bloonlean 是否删除成功
- <span style='color:red'>has</span>       返回布尔值，表示是否是set的成员。
- <span style='color:red'>clear</span>     清除所有，无返回值。
- <span style='color:red'>entries</span>   返回新的迭代器，包含按顺序插入排列的所有元素的[value,value]的值
- <span style='color:red'>forEach</span>   按照插入插入顺序，为Set对象每个值调用callback
- <span style='color:red'>keys</span>      返回新的迭代器对象，包含Set对象中的按照插入顺序排列的所有元素的值
- <span style='color:red'>values</span>    返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
- <span style='color:red'>Set.prototype[@@iterator]()</span> 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。

## 5.使用示例
>去重

```
Array.from(new Set([1,1,2])); // [1,2]
```

>遍历操作、遍历运算

```
new Set([1,2]).keys(); // 返回键名的遍历器。
new Set([1,2]).values(); // 返回键名的遍历器。
new Set([1,2]).entries(); // 返回键值对的遍历器
new Set([1,2]).forEach();// 遍历每个成员 Set的遍历顺序就是插入顺序。
// 可以直接使用 for of 循环遍历Set
// ... 运算符可以用于展开set,扩展运算符和Set结构结合，可以去从
let arry=[1,2,3,4,5,5];
let unique=[...new Set(arr)];// [1,2,3,4,5]
[...set].map(x=>x*2); // 返回的数组为每一个都*2 x=>x*2 相当于 (x)=>{return x*2} 以及 (x)=>(x*2) 括号隐式return
[...set].filter(x=>(x % 2)==0);// [1,2,3,4]后面写条件 比如has=>// [2,4]

// 因为是集合所以对于交集、去重、并集、差集很好的去处理
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}
// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}

```
## 6.时间复杂度

- 数组用来搜索元素的时间复杂度为O(N)。当元素越多时间就越长。
- Set一般是使用红黑树实现的，实际上V8是使用哈希实现的，查找复杂度为O(1),所以总体时间为O(N);
- 所以通过多使用Set，可以提高代码的性能

# 4.Map
## 1.参数
>iterable

- Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])
- 每个键值对都会添加到新的 Map。
- null 会被当做 undefined。

## 2.属性
- Map.length 
```
属性 length 的值为 0 
```
- get Map[@@species]
```
本构造函数用于创建派生对象。
```
- Map.prototype
```
表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象
```


## 3.描述

- 键的比较是基于 "SameValueZero" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），<span style='color:red'>剩下所有其它的值是根据=== 运算符的结果判断是否相等。</span>
```
map.set(NaN,123);
map.get(NaN);//123
```
- 在目前的ECMAScript规范中 +0 -0 会被Map认为同一个键
```
map.set(-0,123);
map.get(+0);    // 123
```
- 对于同一个值得操作，set两遍会替换之前的值。

>Objects和Maps的比较

- Objects和Maps类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值
- 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。
- Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。
- 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算
- Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。
- Map 在涉及频繁增删键值对的场景下会有些性能优势。

## 4.Map实例
- 所有的Map对象实例都会继承 Map.prototype

>属性

- Map.prototype.constructor
```
返回一个函数，它创建了实例的原型。默认是Map函数
```
- Map.prototype.size
```
返回Map对象的键/值对的数量。
```
## 5.方法
- Map.prototype.clear()
```
移除Map对象的所有键/值对 。
```
- Map.prototype.delete(key)
```
如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false
```
- Map.prototype.entries()
```
返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
```
- Map.prototype.forEach(callbackFn[, thisArg])
```
按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。
```
- Map.prototype.get(key)
```
返回键对应的值，如果不存在，则返回undefined。
```
- Map.prototype.has(key)
```
返回一个布尔值，表示Map实例是否包含键对应的值。
```
- Map.prototype.keys()
```
返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。
```
- Map.prototype.set(key, value)
```
设置Map对象中键的值。返回该Map对象。
```
- Map.prototype.values()
```
返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。
```
- Map.prototype[@@iterator]()
```
返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
```
## 6.使用示例
```
let m = new Map();
let o = { p: 'hello world' };
m.set(o, 'content');
m.get(o);                   // "content"
m.has(o);                   // true
m.delete(o);                // true
m.clear();                  // 清除所有值
m.has(o);
```

- 当Object作为Key时，有时候因为内存地址的不同导致无法取到数据。只有对同一个对象的引用，Map结构才将其视为同一个键。

```
map.set(['a'],'1');
map.get(['a']);    //  undefined
```
>Map转换数组

```
let a = new Map([[1,2],[3,4]])
[...a] // [ [ 1, 2 ], [ 3, 4 ] ]
```
>Map转为对象

```
let a = new Map([[1,2],[3,4]])
let obj = {};
for (let [k, v] of a) {
    obj[k] = v;
}
// { '1': 2, '3': 4 }
```
>对象转为Map

```
let obj={a:1,b:2}
let a=new Map();
for(let key of Object.keys(obj)){
    a.set(key,obj[key])
}
// Map { 'a' => 1, 'b' => 2 }
```
>循环迭代for of

```
let myMap = new Map([['a', 1], ['b', 2]]);
for (let [key, value] of myMap) {
    console.log(`${key}---${value}`);
}
// a---1
// b---2

for (let key of myMap.keys()) {
  console.log(key);
}
// a
// b

for (let value of myMap.values()) {
  console.log(value);
}
// 1
// 2


for (let [key, value] of myMap.entries()) {
  console.log(key + " = " + value);
}
// a = 1
// b = 2

```
>forEach 方法迭代

```
let myMap = new Map([['a', 1], ['b', 2]]);
myMap.forEach((value, key) => {
    console.log(key + ' = ' + value);
}, myMap);

// a = 1
// b = 2
```
>复制或合并Maps

```
// 复制
let myMap = new Map([['a',1]]);
let cloneMyMap = new Map(myMap);

console.log(myMap===cloneMyMap) // false

// 多个Map可以合并，但是会保持键的唯一性，回和Object一样后面的覆盖前面的

// Maps
let myMap = new Map([[1, 1], [2, 2], [3, 3]]);
let myMap2 = new Map([[1, 2], [4, 5]]);
let mergeMap = new Map([...myMap, ...myMap2]);
// Map { 1 => 2, 2 => 2, 3 => 3, 4 => 5 }
// 也可以和数组合并
mergeMap = new Map([...myMap, ...myMap2,[5,'123']]);
// Map { 1 => 2, 2 => 2, 3 => 3, 4 => 5, 5 => '123' }

// Object
let obj = { a: 1 };
let obj2 = { a: 2, b: 3 };
let mergeObj = { ...obj, ...obj2 };
// { a: 2, b: 3 }
```
## 7.Object和Map的应用场景
- Map适用于存储经常发生增减键值对或经常遍历数据集，而Object适用于存储静态数据集。
- Map适用于key的类型比较多的情况，而Object的key必须是String或者Symbol。
- Object适用于需要报错独有的逻辑和属性场景。
- Map适用于需要保持元素顺序的逻辑。

# 5.WeakMap
- <span style='color:red'>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</span>

## 1.语法

```
new WeakMap([iterable])
```

>参数

- iterable，是一个数组（二元数组）或者其他可迭代的且其元素是键值对的对象。每个键值对会被加到新的 WeakMap 里。null 会被当做 undefined。

## 2.为什么在有了Map的情况下还要加WeakMap
- 在 JavaScript 里，map API 可以通过使其四个 API 方法共用两个数组(一个存放键,一个存放值)来实现。
- 给这种 map设置值时会同时将键和值添加到这两个数组的末尾。从而使得键和值的索引在两个数组中相对应。
- 当从该 map取值的时候，需要遍历所有的键，然后使用索引从存储值的数组中检索出相应的值。
- 但这样的实现会有两个很大的缺点，首先赋值和搜索操作都是 O(n) 的时间复杂度( n是键值对的个数)，因为这两个操作都需要遍历全部整个数组来进行匹配。
- 另外一个缺点是可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。
- 相比之下，原生的 WeakMap 持有的是每个键或值对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。
- 原生 WeakMap的结构是特殊且有效的，其用于映射的 key 只有在其没有被回收时才是有效的。
- 正由于这样的弱引用，WeakMap 的 key 是不可枚举的 (没有方法能给出所有的 key)。
- 如果key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，你应该使用 Map。

## 3.方法
- WeakMap.prototype.delete(key)
```
移除key的关联对象。执行后 WeakMap.prototype.has(key)返回false。
```
- WeakMap.prototype.get(key)
```
返回key关联对象, 或者 undefined(没有key关联对象时)。
```
- WeakMap.prototype.has(key)
```
根据是否有key关联对象返回一个Boolean值。
```
- WeakMap.prototype.set(key, value)
```
在WeakMap中设置一组key关联对象，返回这个 WeakMap对象。
```
- ~~WeakMap.prototype.clear()~~
```
从WeakMap中移除所有的 key/value 。 注意，该方法已弃用,但可以通过创建一个空的WeakMap并替换原对象来实现 (参看 WeakMap的后半部分)

let obj={}
let myWeakMap= new WeakMap([[obj,1234]]);
myWeakMap=new WeakMap(); // 这个即可清空
```
# 6.解构赋值
## 1.语法
```
let [a, b] = [10, 20];
console.log(a);         // 10
console.log(b);         // 20

let [a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a);         // 10
console.log(b);         // 20
console.log(rest);      // [30, 40, 50]

let { a, b } = { a: 10, b: 20 };
console.log(a);         // 10
console.log(b);         // 20


let { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };
console.log(a);         // 10
console.log(b);         // 20
console.log(rest);      // {c: 30, d: 40}
```
## 2.描述
- 对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。
- 解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。

## 3.使用方法
### 1.解构数组

>声明变量并赋值时的解构

```
let foo = ['one','two','three'];

let [one,two,three]=foo;
console.log(one);       // "one"
console.log(two);       // "two"
console.log(three);     // "three"
```
>默认值

- 为了防止从数组中取出一个值为undefined的对象，可以在表达式左边的数组中为任意对象预设默认值。

```
let [a = 10, b = 20] = [1];
console.log(a);         // 1
console.log(b);         // 20
```

>交换变量

- 在没有解构赋值的情况下一般交换两个变量需要一个中间变量

```
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a);// 2
console.log(b);// 1
```

>解析方法的返回值

```
function f(){
    return [1,2]
}
let [a,b]=f(); 
console.log(a);// 1
console.log(b);// 2
```

>忽略某些返回值

```
function f(){
    return [1,2,3]
}
let [a,,b]=f();
console.log(a); // 1
console.log(b); // 3
```

>剩余的值赋值一个变量

```
let [a,...b]=[1,2,3]
console.log(a); // 1
console.log(b)  // [2,3]
```

><span style='color:red'>用正则表达式取值</span>

```
function parseProtocol (url) {
    let parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
    if (!parsedURL) {
        return false;
    }
    console.log(parsedURL); // ["https://developer.mozilla.org/en-US/Web/JavaScript", "https", "developer.mozilla.org", "en-US/Web/JavaScript"]

    let [, protocol, fullhost, fullpath] = parsedURL;
    return protocol;
}

console.log(parseProtocol('https://developer.mozilla.org/en-US/Web/JavaScript')); // "https"

```
### 2.解构对象
>基本赋值

```
let {p, q} = {p: 42, q: true};
console.log(p); // 42
console.log(q); // true
```

><span style='color:red'>给新的变量名赋值</span>

```
let o = { a: 1, b: 2 };
let { a: aa, b: bb } = o;
console.log('aa:', aa); // 1
console.log('bb:', bb); // 2
```

>默认值

- 判断条件为undefined

```
let {a=10,b=5}={a:3}
console.log(a) // 3
console.log(b) // 5
```

><span style='color:red'>给新的变量命名并提供默认值</span>

```
let {a:aa=1,b:bb=2}={c:3};
console.log(aa) // 1
console.log(bb)// 2
```

><span style='color:red'>解构嵌套对象和数组</span>

```
const metadata = {
    title: 'Scratchpad',
    translations: [
        {
            title: 'JavaScript-Umgebung',
        },
    ],
    url: '/en-US/docs/Tools/Scratchpad',
};

let {
    title: englishTitle, // rename
    translations: [
        {
            title: localeTitle, // rename
        },
    ],
} = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"

```

><span style='color:red'>For of 迭代和解构</span>

```
let people = [
  {
    name: 'Mike Smith',
    family: {
      mother: 'Jane Smith',
      father: 'Harry Smith',
      sister: 'Samantha Smith'
    },
    age: 35
  },
  {
    name: 'Tom Jones',
    family: {
      mother: 'Norah Jones',
      father: 'Richard Jones',
      brother: 'Howard Jones'
    },
    age: 25
  }
];

for (var {name: n, family: {father: f}} of people) {
  console.log('Name: ' + n + ', Father: ' + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
```
><span style='color:red'>For of 迭代和解构结合默认使用</span>

```
let people = [
    {
        name: 'Mike Smith',
        family: {
            mother: 'Jane Smith',
            // father: 'Harry Smith',
            sister: 'Samantha Smith',
        },
        age: 35,
    },
    {
        name: 'Tom Jones',
        /* family: {
         mother: 'Norah Jones',
         father: 'Richard Jones',
         brother: 'Howard Jones',
         },*/
        age: 25,
    },
];

for (let { name: n, family: { father: f = null } = {} } of people) {
    console.log('Name: ' + n + ', Father: ' + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"

```

><span style='color:red'>函数实参提取数据</span>

```
let params = { a: 1, b: 2, c: 2 };

const executeParams = ({ a, b, c }) => {
    console.log('a:', a);
    console.log('b:', b);
    console.log('c:', c);
};
executeParams(params);

```

>对象属性名解构

```
let key = 'z';
let {[key]:foo}={z:'bar'}
console.log(foo); // bar
```

><span style='color:red'>对象解构中的Rest</span>

```
let {a,b,...rest}={a:1,b:2,c:3,d:4}
console.log(a);     // 1
console.log(b);     // 2
console.log(rest);  // {c:3,d:4}
```

# 7.class

[<span style='color:red'>涉及到原型、原型链问题，请点击此处查看<span>](/2019-04-30-JavaScript原型&原型链深入理解/)

[<span style='color:red'>设计到this相关，请点击此处查看</span>](/2019-07-16-JavaScript%20this/)

## 概述
- ECMAScript6引入的JavaScript类实质上是JavaScript现有的基于原型的继承的语法糖。类语法不会为JavaScript引入新的面向对象的继承模型。

## 1.定义类
- 类实际上是个特殊的函数，就像能够定义的函数表达式和函数声明一养，类语法有两个组成部分：类表达式和类声明。

### 1.类声明
- 定义一个类的一种方法是使用一个类声明
- 类声明不存在变量提升，即先声明后使用。

>示例

```
class myClass{
    constructor(num){
        this.num=num;
    }
}
```


>constructor方法

- 一个类必须有constructor方法，new命令生成对象实例时，自动调用该方法。
- 如果没有显式声明，会被添加默认的constructor方法。
- 默认会返回实例对象this（即空对象 {}）


### 2.类表达式
- 类表达式是定义一个类的另一种方式。类表达式可以是被命名和匿名的。

```
/* 匿名类 */
let myClass = class {
    constructor(num){
        this.num=num;
    }
}
/* 命名的类 */
let myClass2 = class myClass2{
    constructor(num){
        this.num=num;
    }
}
```
### 3.类体和方法定义
- 一个类体是一对花括号/打括号{}中的部分。

#### 1.严格模式

- 类声明和类表达式的主体都执行在严格模式下。构造函数、静态方法、原型方法、getter、setter都在严格模式瞎执行。

#### 2.构造函数

- constructor方法是一个特殊的方法，这种方法用于创建和初始化一个由class创建的对象。
- 一个类只能拥有一个名为constructor的特殊方法。
- 如果类包含多个constructor的方法，则会抛出SystaxError
- 一个构造函数可以使用Super关键字来调用一个父类的构造函数。

#### 3.原型方法
- static关键字用来定义一个类的一个静态方法
- 调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法
- 静态方法通常用于为一个应用程序创建工具函数。

>static

```
class Point {
    constructor (x, y) {
        this.x = x;
        this.y = y;
    }

    static distance (a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);
console.log(Point.distance(p1, p2));
```
#### 4.用原型和静态方法包装
- 如果没有指定this的值，则是undefined，不会指向全局（遵循严格模式）。

>class

```
class Animal {
    speak () {
        return this;
    }

    static eat () {
        return this;
    }
}

let obj = new Animal();
obj.speak(); // Animal {}
let speak = obj.speak;
speak(); // undefined

Animal.eat(); // class Animal
let eat = Animal.eat;
eat(); // undefined
```

>传统方式

- 如果使用传统的基于函数的方式来编写，this会指向到global。

```
function Animal () { }

Animal.prototype.speak = function () {
    return this;
};

Animal.eat = function () {
    return this;
};

let obj = new Animal();
let speak = obj.speak;
speak(); // global object

let eat = Animal.eat;
eat(); // global object
```

### 4.使用extends创建子类、使用super调用超类、静态方法
- extends关键字在类声明或类表达式中用于创建一个类作为另一个类的子类。
- 如果想要调用方法父类的方法需要使用super方法（超类）
- 也可以继承原生构造函数

```
class A {
    constructor (numA, numB) {
        this.a = numA;
        this.b = numB;
    }

    speak () {
        console.log(this.a, this.b);
    }
}

class B extends A {
    speak () {
        super.speak();
        console.log('this.a:', this.a);
        console.log('this.b:', this.b);
    }
}

(new B(1, 2)).speak();
// 1 2 
// this.a:1
// this.a:2
```

>类不能继承常规（非可构造）对象。如果要继承可以使用Object.setPrototypeOf();

```
let Animal = {
    speak () {
        console.log(this.name + ' makes a noise.');
    },
};

class Dog {
    constructor (name) {
        this.name = name;
    }
}

Object.setPrototypeOf(Dog.prototype, Animal);// If you do not do this you will get a TypeError when you invoke speak

let d = new Dog('Mitzie');
d.speak(); // Mitzie makes a noise.

```
><span style='color:red'>静态方法也可继承（但是不可以被实例调用）</span>

```
const bar = Symbol('bar');

class A {
    constructor () {
        this.num = 1;
    }

    static staticEx () {
        console.log('static1');
    }

    get [bar] () {
        return this.getBar();
    }

    setBar = () => {
        return this.getBar();
    };

    getBar () {
        return 123;
    }
}

class B extends A {
    getBar () {
        this.num = 2;
        console.log('this.num:', this.num);
        return super.getBar();
    }
}

B.staticEx(); // static1
```
>如果子类也需要构造函数，需要使用super方法

```
class B extends A {
    constructor () {
        super();
        this.x = 'x';
    }

    getBar () {
        return super.getBar();
    }

    getX () {
        return this.x;
    }
}

console.log((new B()).getX()); // x
```
>类的静态属性和实例属性（可不用在构造函数中定义）


```
// 实例属性类似于在构造函数中声明，即可继承
// 静态属性也可继承

const bar = Symbol('bar');

class A {
    static num3 = 16;

    constructor () {
        this.num = 1;
    }

    static staticEx () {
        console.log('static1');
    }
}

class B extends A {
    num2 = 12;
    static num2 = 13;

    constructor (num) {
        super();
    }

    getNum2 () {
        return this.num2;
    }

}

console.log(B.num3);                // 16
console.log(B.num2);                // 13
console.log((new B()).getNum2());   // 12

```
### 5.Species
- 你可能希望在派生数组类 MyArray 中返回 Array对象。这种 species 方式允许你覆盖默认的构造函数。

>例如，当使用像map()返回默认构造函数的方法时，您希望这些方法返回一个父Array对象，而不是MyArray对象。Symbol.species 符号可以让你这样做：

```
class MyArray extends Array {
    // Overwrite species to the parent Array constructor
    static get [Symbol.species] () { return Array; }
}

let a = new MyArray(1, 2, 3);
let mapped = a.map(x => x * x);

console.log(mapped instanceof MyArray); // false
console.log(mapped instanceof Array); // true

```

### 6.Mix-ins(多重继承)
- 抽象子类或者 mix-ins 是类的模板。
- 一个 ECMAScript 类只能有一个单超类，所以想要从工具类来多重继承的行为是不可能的。
- 子类继承的只能是父类提供的功能性。因此，例如，从工具类的多重继承是不可能的。该功能必须由超类提供。
- 以超类作为输入的函数和一个继承该超类的子类作为输出可以用于在ECMAScript中实现混合

```
var calculatorMixin = Base => class extends Base {
  calc() { }
};

var randomizerMixin = Base => class extends Base {
  randomize() { }
};

class Foo {}

class Bar extends calculatorMixin(randomizerMixin(Foo)) {}
```
### 7.this的指向
- 类的方法内部如果含有this，它默认指向类的实例。如果单独使用就出现报错

>bind

```
const bar = Symbol('bar');

class A {
    constructor () {
        
    }

    get [bar] () {
        return this.getBar();
    }

    setBar () {
        return this.getBar();
    }

    getBar () {
        return 123;
    }
}

let newA = new A();
let { setBar } = newA;
console.log('setBar:', setBar());
// 可以在构造函数bind this
constructor () {
    this.setBar = this.setBar.bind(this);
}
```
>箭头函数

```
const bar = Symbol('bar');

class A {
    constructor () {
        // this.setBar = this.setBar.bind(this);
    }

    get [bar] () {
        return this.getBar();
    }

    setBar = () => {
        return this.getBar();
    };

    getBar () {
        return 123;
    }
}

let newA = new A();
let { setBar } = newA;
console.log('setBar:', setBar());
```
>proxy

- [ ] <span style='color:red'>todo 利用proxy实现</span>

### 8.私有方法、私有变量

>利用Symbol值的唯一性，创建私有变量和私有方法

```
const bar = Symbol('bar');
const barNum = Symbol('barNum');

class A {
    [barNum] = 123;

    constructor () {

    }

    // 私有方法
    [bar] () {
        console.log('bar:', 123);
    }

    getBar () {
        this[bar]();
    }
}

console.log(new A());

```
>利用新特性 #

```
class A {
    #num = 123;
    static #num2 = 1234;

    #privateFun = () => {
        return this.#num;
    };

    getBar = () => {
        return this.#privateFun();
    };

    getPrivateField () {
        return A.#num2;
    }
}

console.log((new A()).getPrivateField()); // 1234
console.log((new A()).getBar());          // 123
```
>利用WeakMap、Map

- 键值对格式
- WeakMap的key必须为引用。
- Map也可以，但是必须也使用引用类型的。
- 利用内存地址的唯一性来实现私有方法
- 只要不暴露唯一引用即可

```
const wm = new WeakMap();

class A {
    constructor () {
        wm.set(this, '这里是私有变量');
    }

    getPrivateField () {
        return wm.get(this);
    }
}

console.log(new A());               // A {}
console.log((new A()).getPrivateField());// 这里是私有变量

```

>[部分内容引用自MDN](https://developer.mozilla.org)

>如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)

# 备注

>2019年7月18日

- 增加let、const
- 增加const TDZ说明

>2019年7月30日

- 增加Set基本用法


>2019年7月31日

- 增加Map、WeakMap基本用法
- 修改Set相关用法

>2019年8月01日

- 完善Set用法
- 增加Set时间复杂度相关
- 增加Map的适用场景

>2019年8月02日

- 增加文章来源备注
- 增加解构相关内容

>2019年8月05日

- 增加class

