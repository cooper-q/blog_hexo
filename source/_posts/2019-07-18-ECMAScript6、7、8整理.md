---
layout: post
title: ECMAScript6、7、8整理
date: 2019-07-18
keywords: 
top: 10
categories: 
    - JavaScript
    - ECMAScript
tags:
    - JavaScript
    - ECMAScript
---
# ECMAScript6、7、8整理
# 1.let
- let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。
- let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，let声明的变量只能是全局或者整个函数块的。
- let声明的变量只在其声明的块或子块中可用
- let与var主要的区别在于var声明的变量的作用域是整个封闭函数。

>语法

```
let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]];
```

>参数

```
var1, var2, …, varN
变量名。必须是合法的标识符。

value1, value2, …, valueN
变量的初始值。可以是任意合法的表达式。
```
## 1.重复声明

- 在同一个函数或块作用域中重复声明同一个变量会引起SyntaxError。

```JavaScript
if (x) {
  let foo;
  let foo; // SyntaxError thrown.
}
```
>switch

- 因为switch只有一个作用块。所以在一个switch中不可声明同一命名的变量。
- 可以通过对case后面创建新的块作用域，形成新的词法环境。

```
// error

switch(x){
    case 0:
        let foo;
        break;
    case 1:
        let foo;    // SyntaxError for redeclaration
        break; 
}

// success

switch(x){
    case 0:{
        let foo;
        break;
    }
    case 1:{
         let foo;    
         break;
    }
}
```

## 2.暂存死区（暂时性死区（TDZ））

- let 被创建在包含该声明的（块）作用域顶部，一般被称为“提升”。
- 通过  var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。
- 在变量初始化前访问该变量会导致ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

```
function do_something() {
  console.log(bar); // undefined
  console.log(foo); // ReferenceError
  var bar = 1;
  let foo = 2;
}
```

> let后跟一个函数传递的参数时将导致循环内部报错。

```
// 因为let n of n.a 是一个作用域 未声明调用 
function go(n){
  for (let n of n.a) { // ReferenceError: n is not defined
    console.log(n);
  }
}

go({a:[1,2,3]});

// 与之var对比
function go(n){
    for (var n of n.a) {
        console.log(n); // 1 2 3
    }
}

go({a:[1,2,3]});

```

>循环定义中的let作用域

```
var i=0;
for(let i=i;i<10;i++){ // i is not defined
    console.log(i);
}

for(let expr1;expr2;expr3) statement
这个例子中expr1、expr2、expr3、statement都包含再一个隐含域块中。
```

## 3.块级作用域

>利用块级作用域声明同样名称的变量名

```
let a='1';
function a(){
    let a='2';
    console.log(a);//2
    if(true){
        let a='3';
        console.log(a);//3
    }
}
```
>利用块级作用域声明函数

- 声明函数相当于let声明方法，所以有块级作用域，可以重复声明，只有在有大括号的情况下可以声明。
- 在处理构造函数时就可以直接使用let而不是用闭包来创建私有变量

```
function func(){
    if(true){
        function a(){
            console.log(1);//1
        }
        a();
    }
}

```

## 3.总结

- let只在他所在代码块有效。
- 不存在变量提升，必须先声明后使用
- 暂时性死区。TDZ 不受外部影响。（函数外与函数内可以声明统一命名的变量）
- do表达式


# 2.const
    
- 一旦声明变量不允许改变。
- 并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
- 对于简单类型的数据，值就是指向的那个内存地址，因此等于常量。
- 只能保证指针是固定的，至于他指向的数据结构是不是可变的，就不能完全控制了，所以可以用作统计count之类的东西。是没有变量提升的。
- let的暂存死区同样适用于const
- 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

```
const a={
    count:0
}
function b(){
    a.count=a.count+1;
}

作用域也是块级作用域。
```

>声明变量的六种方法

```
// ES5:

var function

// ES6:

let const import class
```

>顶层的对象的属性

```
浏览器: window对象
Node:global
es5，全局变量就是顶层对象。
es6，全局变量逐步与顶层对象的属性脱钩。
```
# 3.Set
- Set 可以去从但是适用于数组或者类似数组的对象作为参数，去从限制在同类型之间。
- Set加入值得时候，不会发生类型转换，所以5和'5'是两个不同的值,使用===来判断。
- 两个对象总是不相等的，因为地址不同。地址为唯一标识。
- NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。

```
const s = new Set([1,2,3,4,4]);// 1,2,3,4 
```
## 1.参数
- iterable，如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空

## 2.描述
- Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。

## 3.属性

- size 成员总数
- constructor 构造函数

## 4.方法

- <span style='color:red'>add</span>       添加某个值，返回Set结构本身。
- <span style='color:red'>delete</span>   删除某个值，返回bloonlean 是否删除成功
- <span style='color:red'>has</span>       返回布尔值，表示是否是set的成员。
- <span style='color:red'>clear</span>     清除所有，无返回值。
- <span style='color:red'>entries</span>   返回新的迭代器，包含按顺序插入排列的所有元素的[value,value]的值
- <span style='color:red'>forEach</span>   按照插入插入顺序，为Set对象每个值调用callback
- <span style='color:red'>keys</span>      返回新的迭代器对象，包含Set对象中的按照插入顺序排列的所有元素的值
- <span style='color:red'>values</span>    返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
- <span style='color:red'>Set.prototype[@@iterator]()</span> 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。

## 5.使用示例
>去重

```
Array.from(new Set([1,1,2])); // [1,2]
```

>遍历操作、遍历运算

```
new Set([1,2]).keys(); // 返回键名的遍历器。
new Set([1,2]).values(); // 返回键名的遍历器。
new Set([1,2]).entries(); // 返回键值对的遍历器
new Set([1,2]).forEach();// 遍历每个成员 Set的遍历顺序就是插入顺序。
// 可以直接使用 for of 循环遍历Set
// ... 运算符可以用于展开set,扩展运算符和Set结构结合，可以去从
let arry=[1,2,3,4,5,5];
let unique=[...new Set(arr)];// [1,2,3,4,5]
[...set].map(x=>x*2); // 返回的数组为每一个都*2 x=>x*2 相当于 (x)=>{return x*2} 以及 (x)=>(x*2) 括号隐式return
[...set].filter(x=>(x % 2)==0);// [1,2,3,4]后面写条件 比如has=>// [2,4]

// 因为是集合所以对于交集、去重、并集、差集很好的去处理
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}
// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}

```
## 6.时间复杂度

- 数组用来搜索元素的时间复杂度为O(N)。当元素越多时间就越长。
- Set一般是使用红黑树实现的，实际上V8是使用哈希实现的，查找复杂度为O(1),所以总体时间为O(N);
- 所以通过多使用Set，可以提高代码的性能

# 4.Map
## 1.参数
>iterable

- Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])
- 每个键值对都会添加到新的 Map。
- null 会被当做 undefined。

## 2.属性
- Map.length 
```
属性 length 的值为 0 
```
- get Map[@@species]
```
本构造函数用于创建派生对象。
```
- Map.prototype
```
表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象
```


## 3.描述

- 键的比较是基于 "SameValueZero" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），<span style='color:red'>剩下所有其它的值是根据=== 运算符的结果判断是否相等。</span>
```
map.set(NaN,123);
map.get(NaN);//123
```
- 在目前的ECMAScript规范中 +0 -0 会被Map认为同一个键
```
map.set(-0,123);
map.get(+0);    // 123
```
- 对于同一个值得操作，set两遍会替换之前的值。

>Objects和Maps的比较

- Objects和Maps类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值
- 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。
- Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。
- 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算
- Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代
- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。
- Map 在涉及频繁增删键值对的场景下会有些性能优势。

## 4.Map实例
- 所有的Map对象实例都会继承 Map.prototype

>属性

- Map.prototype.constructor
```
返回一个函数，它创建了实例的原型。默认是Map函数
```
- Map.prototype.size
```
返回Map对象的键/值对的数量。
```
## 5.方法
- Map.prototype.clear()
```
移除Map对象的所有键/值对 。
```
- Map.prototype.delete(key)
```
如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false
```
- Map.prototype.entries()
```
返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
```
- Map.prototype.forEach(callbackFn[, thisArg])
```
按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。
```
- Map.prototype.get(key)
```
返回键对应的值，如果不存在，则返回undefined。
```
- Map.prototype.has(key)
```
返回一个布尔值，表示Map实例是否包含键对应的值。
```
- Map.prototype.keys()
```
返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。
```
- Map.prototype.set(key, value)
```
设置Map对象中键的值。返回该Map对象。
```
- Map.prototype.values()
```
返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。
```
- Map.prototype[@@iterator]()
```
返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。
```
## 6.使用示例
```
let m = new Map();
let o = { p: 'hello world' };
m.set(o, 'content');
m.get(o);                   // "content"
m.has(o);                   // true
m.delete(o);                // true
m.clear();                  // 清除所有值
m.has(o);
```

- 当Object作为Key时，有时候因为内存地址的不同导致无法取到数据。只有对同一个对象的引用，Map结构才将其视为同一个键。

```
map.set(['a'],'1');
map.get(['a']);    //  undefined
```
>Map转换数组

```
let a = new Map([[1,2],[3,4]])
[...a] // [ [ 1, 2 ], [ 3, 4 ] ]
```
>Map转为对象

```
let a = new Map([[1,2],[3,4]])
let obj = {};
for (let [k, v] of a) {
    obj[k] = v;
}
// { '1': 2, '3': 4 }
```
>对象转为Map

```
let obj={a:1,b:2}
let a=new Map();
for(let key of Object.keys(obj)){
    a.set(key,obj[key])
}
// Map { 'a' => 1, 'b' => 2 }
```
>循环迭代for of

```
let myMap = new Map([['a', 1], ['b', 2]]);
for (let [key, value] of myMap) {
    console.log(`${key}---${value}`);
}
// a---1
// b---2

for (let key of myMap.keys()) {
  console.log(key);
}
// a
// b

for (let value of myMap.values()) {
  console.log(value);
}
// 1
// 2


for (let [key, value] of myMap.entries()) {
  console.log(key + " = " + value);
}
// a = 1
// b = 2

```
>forEach 方法迭代

```
let myMap = new Map([['a', 1], ['b', 2]]);
myMap.forEach((value, key) => {
    console.log(key + ' = ' + value);
}, myMap);

// a = 1
// b = 2
```
>复制或合并Maps

```
// 复制
let myMap = new Map([['a',1]]);
let cloneMyMap = new Map(myMap);

console.log(myMap===cloneMyMap) // false

// 多个Map可以合并，但是会保持键的唯一性，回和Object一样后面的覆盖前面的

// Maps
let myMap = new Map([[1, 1], [2, 2], [3, 3]]);
let myMap2 = new Map([[1, 2], [4, 5]]);
let mergeMap = new Map([...myMap, ...myMap2]);
// Map { 1 => 2, 2 => 2, 3 => 3, 4 => 5 }
// 也可以和数组合并
mergeMap = new Map([...myMap, ...myMap2,[5,'123']]);
// Map { 1 => 2, 2 => 2, 3 => 3, 4 => 5, 5 => '123' }

// Object
let obj = { a: 1 };
let obj2 = { a: 2, b: 3 };
let mergeObj = { ...obj, ...obj2 };
// { a: 2, b: 3 }
```
## 7.Object和Map的应用场景
- Map适用于存储经常发生增减键值对或经常遍历数据集，而Object适用于存储静态数据集。
- Map适用于key的类型比较多的情况，而Object的key必须是String或者Symbol。
- Object适用于需要报错独有的逻辑和属性场景。
- Map适用于需要保持元素顺序的逻辑。

# 5.WeakMap
- <span style='color:red'>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</span>

## 1.语法

```
new WeakMap([iterable])
```

>参数

- iterable，是一个数组（二元数组）或者其他可迭代的且其元素是键值对的对象。每个键值对会被加到新的 WeakMap 里。null 会被当做 undefined。

## 2.为什么在有了Map的情况下还要加WeakMap
- 在 JavaScript 里，map API 可以通过使其四个 API 方法共用两个数组(一个存放键,一个存放值)来实现。
- 给这种 map设置值时会同时将键和值添加到这两个数组的末尾。从而使得键和值的索引在两个数组中相对应。
- 当从该 map取值的时候，需要遍历所有的键，然后使用索引从存储值的数组中检索出相应的值。
- 但这样的实现会有两个很大的缺点，首先赋值和搜索操作都是 O(n) 的时间复杂度( n是键值对的个数)，因为这两个操作都需要遍历全部整个数组来进行匹配。
- 另外一个缺点是可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。
- 相比之下，原生的 WeakMap 持有的是每个键或值对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。
- 原生 WeakMap的结构是特殊且有效的，其用于映射的 key 只有在其没有被回收时才是有效的。
- 正由于这样的弱引用，WeakMap 的 key 是不可枚举的 (没有方法能给出所有的 key)。
- 如果key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，你应该使用 Map。

## 3.方法
- WeakMap.prototype.delete(key)
```
移除key的关联对象。执行后 WeakMap.prototype.has(key)返回false。
```
- WeakMap.prototype.get(key)
```
返回key关联对象, 或者 undefined(没有key关联对象时)。
```
- WeakMap.prototype.has(key)
```
根据是否有key关联对象返回一个Boolean值。
```
- WeakMap.prototype.set(key, value)
```
在WeakMap中设置一组key关联对象，返回这个 WeakMap对象。
```
- ~~WeakMap.prototype.clear()~~
```
从WeakMap中移除所有的 key/value 。 注意，该方法已弃用,但可以通过创建一个空的WeakMap并替换原对象来实现 (参看 WeakMap的后半部分)

let obj={}
let myWeakMap= new WeakMap([[obj,1234]]);
myWeakMap=new WeakMap(); // 这个即可清空
```
# 6.解构赋值
## 1.语法
```
let [a, b] = [10, 20];
console.log(a);         // 10
console.log(b);         // 20

let [a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a);         // 10
console.log(b);         // 20
console.log(rest);      // [30, 40, 50]

let { a, b } = { a: 10, b: 20 };
console.log(a);         // 10
console.log(b);         // 20


let { a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 };
console.log(a);         // 10
console.log(b);         // 20
console.log(rest);      // {c: 30, d: 40}
```
## 2.描述
- 对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。
- 解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。

## 3.使用方法
### 1.解构数组

>声明变量并赋值时的解构

```
let foo = ['one','two','three'];

let [one,two,three]=foo;
console.log(one);       // "one"
console.log(two);       // "two"
console.log(three);     // "three"
```
>默认值

- 为了防止从数组中取出一个值为undefined的对象，可以在表达式左边的数组中为任意对象预设默认值。

```
let [a = 10, b = 20] = [1];
console.log(a);         // 1
console.log(b);         // 20
```

>交换变量

- 在没有解构赋值的情况下一般交换两个变量需要一个中间变量

```
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a);// 2
console.log(b);// 1
```

>解析方法的返回值

```
function f(){
    return [1,2]
}
let [a,b]=f(); 
console.log(a);// 1
console.log(b);// 2
```

>忽略某些返回值

```
function f(){
    return [1,2,3]
}
let [a,,b]=f();
console.log(a); // 1
console.log(b); // 3
```

>剩余的值赋值一个变量

```
let [a,...b]=[1,2,3]
console.log(a); // 1
console.log(b)  // [2,3]
```

><span style='color:red'>用正则表达式取值</span>

```
function parseProtocol (url) {
    let parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
    if (!parsedURL) {
        return false;
    }
    console.log(parsedURL); // ["https://developer.mozilla.org/en-US/Web/JavaScript", "https", "developer.mozilla.org", "en-US/Web/JavaScript"]

    let [, protocol, fullhost, fullpath] = parsedURL;
    return protocol;
}

console.log(parseProtocol('https://developer.mozilla.org/en-US/Web/JavaScript')); // "https"

```
### 2.解构对象
>基本赋值

```
let {p, q} = {p: 42, q: true};
console.log(p); // 42
console.log(q); // true
```

><span style='color:red'>给新的变量名赋值</span>

```
let o = { a: 1, b: 2 };
let { a: aa, b: bb } = o;
console.log('aa:', aa); // 1
console.log('bb:', bb); // 2
```

>默认值

- 判断条件为undefined

```
let {a=10,b=5}={a:3}
console.log(a) // 3
console.log(b) // 5
```

><span style='color:red'>给新的变量命名并提供默认值</span>

```
let {a:aa=1,b:bb=2}={c:3};
console.log(aa) // 1
console.log(bb)// 2
```

><span style='color:red'>解构嵌套对象和数组</span>

```
const metadata = {
    title: 'Scratchpad',
    translations: [
        {
            title: 'JavaScript-Umgebung',
        },
    ],
    url: '/en-US/docs/Tools/Scratchpad',
};

let {
    title: englishTitle, // rename
    translations: [
        {
            title: localeTitle, // rename
        },
    ],
} = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"

```

><span style='color:red'>For of 迭代和解构</span>

```
let people = [
  {
    name: 'Mike Smith',
    family: {
      mother: 'Jane Smith',
      father: 'Harry Smith',
      sister: 'Samantha Smith'
    },
    age: 35
  },
  {
    name: 'Tom Jones',
    family: {
      mother: 'Norah Jones',
      father: 'Richard Jones',
      brother: 'Howard Jones'
    },
    age: 25
  }
];

for (var {name: n, family: {father: f}} of people) {
  console.log('Name: ' + n + ', Father: ' + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
```
><span style='color:red'>For of 迭代和解构结合默认使用</span>

```
let people = [
    {
        name: 'Mike Smith',
        family: {
            mother: 'Jane Smith',
            // father: 'Harry Smith',
            sister: 'Samantha Smith',
        },
        age: 35,
    },
    {
        name: 'Tom Jones',
        /* family: {
         mother: 'Norah Jones',
         father: 'Richard Jones',
         brother: 'Howard Jones',
         },*/
        age: 25,
    },
];

for (let { name: n, family: { father: f = null } = {} } of people) {
    console.log('Name: ' + n + ', Father: ' + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"

```

><span style='color:red'>函数实参提取数据</span>

```
let params = { a: 1, b: 2, c: 2 };

const executeParams = ({ a, b, c }) => {
    console.log('a:', a);
    console.log('b:', b);
    console.log('c:', c);
};
executeParams(params);

```

>对象属性名解构

```
let key = 'z';
let {[key]:foo}={z:'bar'}
console.log(foo); // bar
```

><span style='color:red'>对象解构中的Rest</span>

```
let {a,b,...rest}={a:1,b:2,c:3,d:4}
console.log(a);     // 1
console.log(b);     // 2
console.log(rest);  // {c:3,d:4}
```

# 7.class

>[部分内容引用自MDN](https://developer.mozilla.org)

>如有侵权行为，请[点击这里](https://github.com/mattmengCooper/MattMeng_hexo/issues)联系我删除

>[如发现疑问或者错误点击反馈](https://github.com/mattmengCooper/MattMeng_hexo/issues)

# 备注

